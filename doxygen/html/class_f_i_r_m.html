<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EDPL-OMPL: FIRM Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EDPL-OMPL
   &#160;<span id="projectnumber">0.4</span>
   </div>
   <div id="projectbrief">TAMU</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_f_i_r_m-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FIRM Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Feedback Information RoadMap planner.  
 <a href="class_f_i_r_m.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_f_i_r_m_8h_source.html">FIRM.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FIRM:</div>
<div class="dyncontent">
<div class="center"><img src="class_f_i_r_m__inherit__graph.png" border="0" usemap="#_f_i_r_m_inherit__map" alt="Inheritance graph"/></div>
<map name="_f_i_r_m_inherit__map" id="_f_i_r_m_inherit__map">
<area shape="rect" id="node3" href="class_f_i_r_m_c_p.html" title="FIRMCP" alt="" coords="37,155,112,181"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for FIRM:</div>
<div class="dyncontent">
<div class="center"><img src="class_f_i_r_m__coll__graph.png" border="0" usemap="#_f_i_r_m_coll__map" alt="Collaboration graph"/></div>
<map name="_f_i_r_m_coll__map" id="_f_i_r_m_coll__map">
<area shape="rect" id="node3" href="class_n_b_m3_p.html" title="NBM3P" alt="" coords="169,5,237,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_i_r_m_1_1edge__flags__t.html">edge_flags_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_i_r_m_1_1vertex__flags__t.html">vertex_flags_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_i_r_m_1_1vertex__state__t.html">vertex_state_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_i_r_m_1_1vertex__successful__connection__attempts__t.html">vertex_successful_connection_attempts_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_i_r_m_1_1vertex__total__connection__attempts__t.html">vertex_total_connection_attempts_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a687e9f4243b22c30ee1fa5da22a85053"><td class="memItemLeft" align="right" valign="top">typedef boost::adjacency_list&lt; boost::vecS, boost::vecS, boost::bidirectionalS, boost::property&lt; <a class="el" href="struct_f_i_r_m_1_1vertex__state__t.html">vertex_state_t</a>, ompl::base::State *, boost::property&lt; <a class="el" href="struct_f_i_r_m_1_1vertex__total__connection__attempts__t.html">vertex_total_connection_attempts_t</a>, unsigned int, boost::property&lt; <a class="el" href="struct_f_i_r_m_1_1vertex__successful__connection__attempts__t.html">vertex_successful_connection_attempts_t</a>, unsigned int, boost::property&lt; <a class="el" href="struct_f_i_r_m_1_1vertex__flags__t.html">vertex_flags_t</a>, unsigned int, boost::property&lt; boost::vertex_predecessor_t, unsigned long int, boost::property&lt; boost::vertex_rank_t, unsigned long int &gt; &gt; &gt; &gt; &gt; &gt;, boost::property&lt; boost::edge_weight_t, <a class="el" href="class_f_i_r_m_weight.html">FIRMWeight</a>, boost::property&lt; boost::edge_index_t, unsigned int, boost::property&lt; <a class="el" href="struct_f_i_r_m_1_1edge__flags__t.html">edge_flags_t</a>, unsigned int &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a></td></tr>
<tr class="memdesc:a687e9f4243b22c30ee1fa5da22a85053"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying roadmap graph.  <a href="#a687e9f4243b22c30ee1fa5da22a85053">More...</a><br /></td></tr>
<tr class="separator:a687e9f4243b22c30ee1fa5da22a85053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07eb05796ed64797c900b193aafa9031"><td class="memItemLeft" align="right" valign="top"><a id="a07eb05796ed64797c900b193aafa9031"></a>
typedef boost::graph_traits&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a> &gt;::vertex_descriptor&#160;</td><td class="memItemRight" valign="bottom"><b>Vertex</b></td></tr>
<tr class="separator:a07eb05796ed64797c900b193aafa9031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88889998bf429572821d467eb44c67c6"><td class="memItemLeft" align="right" valign="top"><a id="a88889998bf429572821d467eb44c67c6"></a>
typedef boost::graph_traits&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a> &gt;::edge_descriptor&#160;</td><td class="memItemRight" valign="bottom"><b>Edge</b></td></tr>
<tr class="separator:a88889998bf429572821d467eb44c67c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52259e46a3f9a92099bf0b66af26a52c"><td class="memItemLeft" align="right" valign="top"><a id="a52259e46a3f9a92099bf0b66af26a52c"></a>
typedef std::shared_ptr&lt; ompl::NearestNeighbors&lt; Vertex &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RoadmapNeighbors</b></td></tr>
<tr class="separator:a52259e46a3f9a92099bf0b66af26a52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0ce9293fe4c9efb64248390a0e4e5b"><td class="memItemLeft" align="right" valign="top"><a id="abf0ce9293fe4c9efb64248390a0e4e5b"></a>
typedef std::function&lt; std::vector&lt; Vertex &gt; &amp;(const Vertex, double radius)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#abf0ce9293fe4c9efb64248390a0e4e5b">ConnectionStrategy</a></td></tr>
<tr class="memdesc:abf0ce9293fe4c9efb64248390a0e4e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function returning the milestones that should be attempted to connect to. <br /></td></tr>
<tr class="separator:abf0ce9293fe4c9efb64248390a0e4e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e9eb1fa5c484b15234cc7b5e5d4e2f"><td class="memItemLeft" align="right" valign="top"><a id="ad7e9eb1fa5c484b15234cc7b5e5d4e2f"></a>
typedef std::function&lt; std::vector&lt; Vertex &gt; &amp;(const Vertex, std::size_t k)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ad7e9eb1fa5c484b15234cc7b5e5d4e2f">KConnectionStrategy</a></td></tr>
<tr class="memdesc:ad7e9eb1fa5c484b15234cc7b5e5d4e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function returning the milestones that should be attempted to connect to. <br /></td></tr>
<tr class="separator:ad7e9eb1fa5c484b15234cc7b5e5d4e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72698e6a88b85d177a4da97e2b50377"><td class="memItemLeft" align="right" valign="top"><a id="ab72698e6a88b85d177a4da97e2b50377"></a>
typedef <a class="el" href="class_controller.html">Controller</a>&lt; <a class="el" href="class_f_i_r_m.html#a51f42e7d6bfd259ff5998083e02af08a">SeparatedControllerType</a>, <a class="el" href="class_f_i_r_m.html#a20f301d4dc3945deb4d14f36d39bacfd">FilterType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EdgeControllerType</b></td></tr>
<tr class="separator:ab72698e6a88b85d177a4da97e2b50377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d719981dd4818eb8e373260908e20a"><td class="memItemLeft" align="right" valign="top"><a id="a16d719981dd4818eb8e373260908e20a"></a>
typedef <a class="el" href="class_controller.html">Controller</a>&lt; <a class="el" href="class_stationary_l_q_r.html">NodeSeparatedControllerType</a>, <a class="el" href="class_linearized_k_f.html">LinearizedKF</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodeControllerType</b></td></tr>
<tr class="separator:a16d719981dd4818eb8e373260908e20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a451aef223259f497ec178ad8447d04d5"><td class="memItemLeft" align="right" valign="top"><a id="a451aef223259f497ec178ad8447d04d5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a451aef223259f497ec178ad8447d04d5">FIRM</a> (const firm::SpaceInformation::SpaceInformationPtr &amp;si, bool debugMode=false)</td></tr>
<tr class="memdesc:a451aef223259f497ec178ad8447d04d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a451aef223259f497ec178ad8447d04d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a7ff97d8202a82ca7f6dddfd7ba185"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a09a7ff97d8202a82ca7f6dddfd7ba185">setProblemDefinition</a> (const ompl::base::ProblemDefinitionPtr &amp;pdef)</td></tr>
<tr class="memdesc:a09a7ff97d8202a82ca7f6dddfd7ba185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the connection strategy function that specifies the milestones that connection attempts will be made to for a given milestone.  <a href="#a09a7ff97d8202a82ca7f6dddfd7ba185">More...</a><br /></td></tr>
<tr class="separator:a09a7ff97d8202a82ca7f6dddfd7ba185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8017d1847e682f39c2cbce33e904af57"><td class="memItemLeft" align="right" valign="top"><a id="a8017d1847e682f39c2cbce33e904af57"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a8017d1847e682f39c2cbce33e904af57">setConnectionStrategy</a> (const <a class="el" href="class_f_i_r_m.html#abf0ce9293fe4c9efb64248390a0e4e5b">ConnectionStrategy</a> &amp;connectionStrategy)</td></tr>
<tr class="memdesc:a8017d1847e682f39c2cbce33e904af57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function that sets the connection strategy to the default one with k nearest neighbors. <br /></td></tr>
<tr class="separator:a8017d1847e682f39c2cbce33e904af57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a87b6c094c21b956a469a2b69cd387c"><td class="memItemLeft" align="right" valign="top"><a id="a2a87b6c094c21b956a469a2b69cd387c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setMaxNearestNeighbors</b> (unsigned int k)</td></tr>
<tr class="separator:a2a87b6c094c21b956a469a2b69cd387c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2e6a8c5dac3a0629f1dd0ac2313b9c"><td class="memItemLeft" align="right" valign="top"><a id="a5f2e6a8c5dac3a0629f1dd0ac2313b9c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a5f2e6a8c5dac3a0629f1dd0ac2313b9c">constructRoadmap</a> (const ompl::base::PlannerTerminationCondition &amp;ptc)</td></tr>
<tr class="memdesc:a5f2e6a8c5dac3a0629f1dd0ac2313b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">While the termination condition allows, this function will construct the roadmap (using <a class="el" href="class_f_i_r_m.html#a947186c6e6be0b513efe0e0b476fef88" title="If the user desires, the roadmap can be improved for the given time (seconds). The solve() method wil...">growRoadmap()</a> and <a class="el" href="class_f_i_r_m.html#ad9cd5472a8bd1b1fcb83763128f7fd75" title="Attempt to connect disjoint components in the roadmap using random bouncing motions (the PRM expansio...">expandRoadmap()</a>, maintaining a 2:1 ratio for growing/expansion of roadmap) <br /></td></tr>
<tr class="separator:a5f2e6a8c5dac3a0629f1dd0ac2313b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947186c6e6be0b513efe0e0b476fef88"><td class="memItemLeft" align="right" valign="top"><a id="a947186c6e6be0b513efe0e0b476fef88"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a947186c6e6be0b513efe0e0b476fef88">growRoadmap</a> (double growTime)</td></tr>
<tr class="memdesc:a947186c6e6be0b513efe0e0b476fef88"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the user desires, the roadmap can be improved for the given time (seconds). The <a class="el" href="class_f_i_r_m.html#a02f3c98de4840594193ba5bf7ff3ca63" title="The key function that solves the planning problem. ">solve()</a> method will also improve the roadmap, as needed. <br /></td></tr>
<tr class="separator:a947186c6e6be0b513efe0e0b476fef88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e741b0af39a64d34dcfa4f29c0e509"><td class="memItemLeft" align="right" valign="top"><a id="ae8e741b0af39a64d34dcfa4f29c0e509"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ae8e741b0af39a64d34dcfa4f29c0e509">growRoadmap</a> (const ompl::base::PlannerTerminationCondition &amp;ptc)</td></tr>
<tr class="memdesc:ae8e741b0af39a64d34dcfa4f29c0e509"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the user desires, the roadmap can be improved until a given condition is true. The <a class="el" href="class_f_i_r_m.html#a02f3c98de4840594193ba5bf7ff3ca63" title="The key function that solves the planning problem. ">solve()</a> method will also improve the roadmap, as needed. <br /></td></tr>
<tr class="separator:ae8e741b0af39a64d34dcfa4f29c0e509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9cd5472a8bd1b1fcb83763128f7fd75"><td class="memItemLeft" align="right" valign="top"><a id="ad9cd5472a8bd1b1fcb83763128f7fd75"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ad9cd5472a8bd1b1fcb83763128f7fd75">expandRoadmap</a> (double expandTime)</td></tr>
<tr class="memdesc:ad9cd5472a8bd1b1fcb83763128f7fd75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to connect disjoint components in the roadmap using random bouncing motions (the PRM expansion step) for the given time (seconds). <br /></td></tr>
<tr class="separator:ad9cd5472a8bd1b1fcb83763128f7fd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac520fbbb43b0e3100498aa29117f0b9"><td class="memItemLeft" align="right" valign="top"><a id="aac520fbbb43b0e3100498aa29117f0b9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#aac520fbbb43b0e3100498aa29117f0b9">expandRoadmap</a> (const ompl::base::PlannerTerminationCondition &amp;ptc)</td></tr>
<tr class="memdesc:aac520fbbb43b0e3100498aa29117f0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to connect disjoint components in the roadmap using random bouncing motions (the PRM expansion step) until the given condition evaluates true. <br /></td></tr>
<tr class="separator:aac520fbbb43b0e3100498aa29117f0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f3c98de4840594193ba5bf7ff3ca63"><td class="memItemLeft" align="right" valign="top"><a id="a02f3c98de4840594193ba5bf7ff3ca63"></a>
virtual ompl::base::PlannerStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a02f3c98de4840594193ba5bf7ff3ca63">solve</a> (const ompl::base::PlannerTerminationCondition &amp;ptc)</td></tr>
<tr class="memdesc:a02f3c98de4840594193ba5bf7ff3ca63"><td class="mdescLeft">&#160;</td><td class="mdescRight">The key function that solves the planning problem. <br /></td></tr>
<tr class="separator:a02f3c98de4840594193ba5bf7ff3ca63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7c24814ea6b8cad9cad350dea66560"><td class="memItemLeft" align="right" valign="top"><a id="acf7c24814ea6b8cad9cad350dea66560"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearQuery</b> (void)</td></tr>
<tr class="separator:acf7c24814ea6b8cad9cad350dea66560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5298e85713c7a736d6b8936f7171af"><td class="memItemLeft" align="right" valign="top"><a id="afe5298e85713c7a736d6b8936f7171af"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> (void)</td></tr>
<tr class="separator:afe5298e85713c7a736d6b8936f7171af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd7c5ed3fa065f5f37d79bc1d220474"><td class="memTemplParams" colspan="2"><a id="a8dd7c5ed3fa065f5f37d79bc1d220474"></a>
template&lt;template&lt; typename T &gt; class NN&gt; </td></tr>
<tr class="memitem:a8dd7c5ed3fa065f5f37d79bc1d220474"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a8dd7c5ed3fa065f5f37d79bc1d220474">setNearestNeighbors</a> (void)</td></tr>
<tr class="memdesc:a8dd7c5ed3fa065f5f37d79bc1d220474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a different nearest neighbors datastructure. <br /></td></tr>
<tr class="separator:a8dd7c5ed3fa065f5f37d79bc1d220474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c43a180deb28296e4cab5c6939c600"><td class="memItemLeft" align="right" valign="top"><a id="a78c43a180deb28296e4cab5c6939c600"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setup</b> (void)</td></tr>
<tr class="separator:a78c43a180deb28296e4cab5c6939c600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aebb0ced09d167ea71e479f4f24c44b"><td class="memItemLeft" align="right" valign="top"><a id="a5aebb0ced09d167ea71e479f4f24c44b"></a>
const <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getRoadmap</b> (void) const</td></tr>
<tr class="separator:a5aebb0ced09d167ea71e479f4f24c44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d92b9ca6a598082b5d0f5d29f3a2c7"><td class="memItemLeft" align="right" valign="top"><a id="a27d92b9ca6a598082b5d0f5d29f3a2c7"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a27d92b9ca6a598082b5d0f5d29f3a2c7">distanceFunction</a> (const Vertex a, const Vertex b) const</td></tr>
<tr class="memdesc:a27d92b9ca6a598082b5d0f5d29f3a2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute distance between two milestones (this is simply distance between the states of the milestones) <br /></td></tr>
<tr class="separator:a27d92b9ca6a598082b5d0f5d29f3a2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ec047fa094ad49988a2d6be671b135"><td class="memItemLeft" align="right" valign="top"><a id="af6ec047fa094ad49988a2d6be671b135"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#af6ec047fa094ad49988a2d6be671b135">milestoneCount</a> (void) const</td></tr>
<tr class="memdesc:af6ec047fa094ad49988a2d6be671b135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute distance between two milestones (this is simply distance between the states of the milestones) <br /></td></tr>
<tr class="separator:af6ec047fa094ad49988a2d6be671b135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6df82888d88ab8479f92f9f3e453c2e"><td class="memItemLeft" align="right" valign="top"><a id="ad6df82888d88ab8479f92f9f3e453c2e"></a>
const RoadmapNeighbors &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ad6df82888d88ab8479f92f9f3e453c2e">getNearestNeighbors</a> (void)</td></tr>
<tr class="memdesc:ad6df82888d88ab8479f92f9f3e453c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nearest neighbor structure. <br /></td></tr>
<tr class="separator:ad6df82888d88ab8479f92f9f3e453c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1aa81e7b0c315c4c4214f191059ee2"><td class="memItemLeft" align="right" valign="top"><a id="acd1aa81e7b0c315c4c4214f191059ee2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#acd1aa81e7b0c315c4c4214f191059ee2">compareCostToGo</a> (const std::pair&lt; Vertex, double &gt; &amp;currentVertexCostToGo, const std::pair&lt; Vertex, double &gt; &amp;otherVertexCostToGo)</td></tr>
<tr class="memdesc:acd1aa81e7b0c315c4c4214f191059ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the cost-to-go of the current vertex is greater than that of the other vertex (this is a compare function for the min heap for Dijkstra search) <br /></td></tr>
<tr class="separator:acd1aa81e7b0c315c4c4214f191059ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd8eebb449ec1e3e6512be20e45052b"><td class="memItemLeft" align="right" valign="top"><a id="abdd8eebb449ec1e3e6512be20e45052b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#abdd8eebb449ec1e3e6512be20e45052b">getNewCostToGoViaChild</a> (const Vertex parentVertex, const Vertex childVertex, const double childCostToGo, const Edge edge)</td></tr>
<tr class="memdesc:abdd8eebb449ec1e3e6512be20e45052b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a new cost-to-go of the parent node via this child node. <br /></td></tr>
<tr class="separator:abdd8eebb449ec1e3e6512be20e45052b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae448791d4c9af9016bc9d5e9de166f0e"><td class="memItemLeft" align="right" valign="top"><a id="ae448791d4c9af9016bc9d5e9de166f0e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ae448791d4c9af9016bc9d5e9de166f0e">executeFeedback</a> (void)</td></tr>
<tr class="memdesc:ae448791d4c9af9016bc9d5e9de166f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the generated policy on the system. <br /></td></tr>
<tr class="separator:ae448791d4c9af9016bc9d5e9de166f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcd92332a3e7658e6f81f86b0883ed0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#afbcd92332a3e7658e6f81f86b0883ed0">executeFeedbackWithKidnapping</a> (void)</td></tr>
<tr class="memdesc:afbcd92332a3e7658e6f81f86b0883ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the generated policy on the system with kidnapping in the middle of a run.  <a href="#afbcd92332a3e7658e6f81f86b0883ed0">More...</a><br /></td></tr>
<tr class="separator:afbcd92332a3e7658e6f81f86b0883ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8267860838552b5b433212f142270615"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a8267860838552b5b433212f142270615">executeFeedbackWithRollout</a> (void)</td></tr>
<tr class="memdesc:a8267860838552b5b433212f142270615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the rollout policy algorithm (See ICRA '14 paper)  <a href="#a8267860838552b5b433212f142270615">More...</a><br /></td></tr>
<tr class="separator:a8267860838552b5b433212f142270615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1853095fafc72bba76846d94e8e4eba"><td class="memItemLeft" align="right" valign="top"><a id="af1853095fafc72bba76846d94e8e4eba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#af1853095fafc72bba76846d94e8e4eba">setMinFIRMNodes</a> (const unsigned int numNodes)</td></tr>
<tr class="memdesc:af1853095fafc72bba76846d94e8e4eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimum number of <a class="el" href="class_f_i_r_m.html" title="Feedback Information RoadMap planner. ">FIRM</a> nodes. <br /></td></tr>
<tr class="separator:af1853095fafc72bba76846d94e8e4eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb15af8e74f9b21bc99cca509bc15fc"><td class="memItemLeft" align="right" valign="top"><a id="a2bb15af8e74f9b21bc99cca509bc15fc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a2bb15af8e74f9b21bc99cca509bc15fc">setMaxFIRMNodes</a> (const unsigned int numNodes)</td></tr>
<tr class="memdesc:a2bb15af8e74f9b21bc99cca509bc15fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of <a class="el" href="class_f_i_r_m.html" title="Feedback Information RoadMap planner. ">FIRM</a> nodes. <br /></td></tr>
<tr class="separator:a2bb15af8e74f9b21bc99cca509bc15fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24323d0714ee325851ed0cc74b72c99"><td class="memItemLeft" align="right" valign="top"><a id="aa24323d0714ee325851ed0cc74b72c99"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#aa24323d0714ee325851ed0cc74b72c99">savePlannerData</a> ()</td></tr>
<tr class="memdesc:aa24323d0714ee325851ed0cc74b72c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the roadmap to an XML. <br /></td></tr>
<tr class="separator:aa24323d0714ee325851ed0cc74b72c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2396aa0ee8f3818d059c7b6ea615d0"><td class="memItemLeft" align="right" valign="top"><a id="a8c2396aa0ee8f3818d059c7b6ea615d0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a8c2396aa0ee8f3818d059c7b6ea615d0">loadRoadMapFromFile</a> (const std::string &amp;pathToFile)</td></tr>
<tr class="memdesc:a8c2396aa0ee8f3818d059c7b6ea615d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the roadmap info from a file. <br /></td></tr>
<tr class="separator:a8c2396aa0ee8f3818d059c7b6ea615d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852198c1c52201886ff2720fc423d2f3"><td class="memItemLeft" align="right" valign="top"><a id="a852198c1c52201886ff2720fc423d2f3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a852198c1c52201886ff2720fc423d2f3">loadParametersFromFile</a> (const std::string &amp;pathToFile)</td></tr>
<tr class="memdesc:a852198c1c52201886ff2720fc423d2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load planner parameters specific to this planner. <br /></td></tr>
<tr class="separator:a852198c1c52201886ff2720fc423d2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f1f2e8d35ae53c3356bb93abc6c29b"><td class="memItemLeft" align="right" valign="top"><a id="ad0f1f2e8d35ae53c3356bb93abc6c29b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setKidnappedState</b> (ompl::base::State *state)</td></tr>
<tr class="separator:ad0f1f2e8d35ae53c3356bb93abc6c29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77b14b8cba99654cfa0a008b35f5e93"><td class="memItemLeft" align="right" valign="top"><a id="ac77b14b8cba99654cfa0a008b35f5e93"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ac77b14b8cba99654cfa0a008b35f5e93">setPolicyExecutionSpace</a> (firm::SpaceInformation::SpaceInformationPtr executionSI)</td></tr>
<tr class="memdesc:ac77b14b8cba99654cfa0a008b35f5e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the policy execution space. <br /></td></tr>
<tr class="separator:ac77b14b8cba99654cfa0a008b35f5e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add473be490dca5af8329bc0e3d17a1d8"><td class="memItemLeft" align="right" valign="top"><a id="add473be490dca5af8329bc0e3d17a1d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateCollisionChecker</b> (const ompl::base::StateValidityCheckerPtr &amp;svc)</td></tr>
<tr class="separator:add473be490dca5af8329bc0e3d17a1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a19a4a0bdee490544188864bad8774840"><td class="memItemLeft" align="right" valign="top"><a id="a19a4a0bdee490544188864bad8774840"></a>
typedef <a class="el" href="class_s_e2_belief_space_1_1_state_type.html">SE2BeliefSpace::StateType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>StateType</b></td></tr>
<tr class="separator:a19a4a0bdee490544188864bad8774840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f42e7d6bfd259ff5998083e02af08a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_r_h_c_i_create.html">RHCICreate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a51f42e7d6bfd259ff5998083e02af08a">SeparatedControllerType</a></td></tr>
<tr class="separator:a51f42e7d6bfd259ff5998083e02af08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af395d18bfbb80e00b6de672fa583648b"><td class="memItemLeft" align="right" valign="top"><a id="af395d18bfbb80e00b6de672fa583648b"></a>
typedef <a class="el" href="class_stationary_l_q_r.html">StationaryLQR</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NodeSeparatedControllerType</b></td></tr>
<tr class="separator:af395d18bfbb80e00b6de672fa583648b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f301d4dc3945deb4d14f36d39bacfd"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_extended_k_f.html">ExtendedKF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a20f301d4dc3945deb4d14f36d39bacfd">FilterType</a></td></tr>
<tr class="separator:a20f301d4dc3945deb4d14f36d39bacfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af6951ffec04529fd8da990978d7d8d19"><td class="memItemLeft" align="right" valign="top"><a id="af6951ffec04529fd8da990978d7d8d19"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#af6951ffec04529fd8da990978d7d8d19">freeMemory</a> (void)</td></tr>
<tr class="memdesc:af6951ffec04529fd8da990978d7d8d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all the memory allocated by the planner. <br /></td></tr>
<tr class="separator:af6951ffec04529fd8da990978d7d8d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a5fbf2e61bc7c6719579ae689e7e1c"><td class="memItemLeft" align="right" valign="top"><a id="a08a5fbf2e61bc7c6719579ae689e7e1c"></a>
virtual Vertex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a08a5fbf2e61bc7c6719579ae689e7e1c">addStateToGraph</a> (ompl::base::State *state, bool addReverseEdge=true)</td></tr>
<tr class="memdesc:a08a5fbf2e61bc7c6719579ae689e7e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a graph node for a given state (<em>state</em>), store it in the nearest neighbors data structure and then connect it to the roadmap in accordance to the connection strategy. <br /></td></tr>
<tr class="separator:a08a5fbf2e61bc7c6719579ae689e7e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34535f25e4f3fb645fb65d57e3faf01b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a34535f25e4f3fb645fb65d57e3faf01b">uniteComponents</a> (Vertex m1, Vertex m2)</td></tr>
<tr class="memdesc:a34535f25e4f3fb645fb65d57e3faf01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a state from XML and add to Graph.  <a href="#a34535f25e4f3fb645fb65d57e3faf01b">More...</a><br /></td></tr>
<tr class="separator:a34535f25e4f3fb645fb65d57e3faf01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2045f113f0755ae8eeac2c35c7c08d41"><td class="memItemLeft" align="right" valign="top"><a id="a2045f113f0755ae8eeac2c35c7c08d41"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a2045f113f0755ae8eeac2c35c7c08d41">sameComponent</a> (Vertex m1, Vertex m2)</td></tr>
<tr class="memdesc:a2045f113f0755ae8eeac2c35c7c08d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two milestones (<em>m1</em> and <em>m2</em>) are part of the same connected component. This is not a const function since we use incremental connected components from boost. <br /></td></tr>
<tr class="separator:a2045f113f0755ae8eeac2c35c7c08d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33b03b6c78466e4a47f7b6d9f59d7f8"><td class="memItemLeft" align="right" valign="top"><a id="ae33b03b6c78466e4a47f7b6d9f59d7f8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ae33b03b6c78466e4a47f7b6d9f59d7f8">growRoadmap</a> (const ompl::base::PlannerTerminationCondition &amp;ptc, ompl::base::State *workState)</td></tr>
<tr class="memdesc:ae33b03b6c78466e4a47f7b6d9f59d7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly sample the state space, add and connect nodes in the roadmap. Stop this process when the termination condition. <br /></td></tr>
<tr class="separator:ae33b03b6c78466e4a47f7b6d9f59d7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d57675e8ab948d7f51af4c53671b9f"><td class="memItemLeft" align="right" valign="top"><a id="ab1d57675e8ab948d7f51af4c53671b9f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ab1d57675e8ab948d7f51af4c53671b9f">expandRoadmap</a> (const ompl::base::PlannerTerminationCondition &amp;ptc, std::vector&lt; ompl::base::State *&gt; &amp;workStates)</td></tr>
<tr class="memdesc:ab1d57675e8ab948d7f51af4c53671b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to connect disjoint components in the roadmap using random bounding motions (the PRM expansion step) <br /></td></tr>
<tr class="separator:ab1d57675e8ab948d7f51af4c53671b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c909fc53ceeeecb6992ccebf0ab60d6"><td class="memItemLeft" align="right" valign="top"><a id="a4c909fc53ceeeecb6992ccebf0ab60d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a4c909fc53ceeeecb6992ccebf0ab60d6">checkForSolution</a> (const ompl::base::PlannerTerminationCondition &amp;ptc, ompl::base::PathPtr &amp;solution)</td></tr>
<tr class="memdesc:a4c909fc53ceeeecb6992ccebf0ab60d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread that checks for solution. <br /></td></tr>
<tr class="separator:a4c909fc53ceeeecb6992ccebf0ab60d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937a58c35d6f8d5c26d09acbcc340d9a"><td class="memItemLeft" align="right" valign="top"><a id="a937a58c35d6f8d5c26d09acbcc340d9a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a937a58c35d6f8d5c26d09acbcc340d9a">existsPolicy</a> (const std::vector&lt; Vertex &gt; &amp;starts, const std::vector&lt; Vertex &gt; &amp;goals, ompl::base::PathPtr &amp;solution)</td></tr>
<tr class="memdesc:a937a58c35d6f8d5c26d09acbcc340d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there exists a policy, i.e., The given pair of <em>start</em> and <em>goal</em>, are in the same connected component. If a feedback policy is found, it is saved. <br /></td></tr>
<tr class="separator:a937a58c35d6f8d5c26d09acbcc340d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa567ec154f7c16f3d371e1d0acba6e05"><td class="memItemLeft" align="right" valign="top"><a id="aa567ec154f7c16f3d371e1d0acba6e05"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#aa567ec154f7c16f3d371e1d0acba6e05">addedNewSolution</a> (void) const</td></tr>
<tr class="memdesc:aa567ec154f7c16f3d371e1d0acba6e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the addedSolution_ member. <br /></td></tr>
<tr class="separator:aa567ec154f7c16f3d371e1d0acba6e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c03bc045b78c8b7d4f66b9a23e83c08"><td class="memItemLeft" align="right" valign="top"><a id="a6c03bc045b78c8b7d4f66b9a23e83c08"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a6c03bc045b78c8b7d4f66b9a23e83c08">constructFeedbackPath</a> (const Vertex &amp;start, const Vertex &amp;goal, ompl::base::PathPtr &amp;solution)</td></tr>
<tr class="memdesc:a6c03bc045b78c8b7d4f66b9a23e83c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a feedback. <br /></td></tr>
<tr class="separator:a6c03bc045b78c8b7d4f66b9a23e83c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d84fb80989b6ca818d91f9972c89db1"><td class="memItemLeft" align="right" valign="top"><a id="a6d84fb80989b6ca818d91f9972c89db1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a6d84fb80989b6ca818d91f9972c89db1">addEdgeToGraph</a> (const FIRM::Vertex a, const FIRM::Vertex b, bool &amp;edgeAdded, const bool addReverseEdge=true)</td></tr>
<tr class="memdesc:a6d84fb80989b6ca818d91f9972c89db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an edge from vertex a to b in graph. <br /></td></tr>
<tr class="separator:a6d84fb80989b6ca818d91f9972c89db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3970d03a911c680d7035568edaae2e7"><td class="memItemLeft" align="right" valign="top"><a id="aa3970d03a911c680d7035568edaae2e7"></a>
virtual <a class="el" href="class_f_i_r_m_weight.html">FIRMWeight</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#aa3970d03a911c680d7035568edaae2e7">generateEdgeNodeControllerWithCost</a> (const Vertex a, const Vertex b, <a class="el" href="class_controller.html">EdgeControllerType</a> &amp;edgeController, const bool constructionMode=true)</td></tr>
<tr class="memdesc:aa3970d03a911c680d7035568edaae2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the cost of the edge controlled by concatenated edge/node controllers. <br /></td></tr>
<tr class="separator:aa3970d03a911c680d7035568edaae2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0119a577b6e1e150ccb79b532c5d595"><td class="memItemLeft" align="right" valign="top"><a id="ab0119a577b6e1e150ccb79b532c5d595"></a>
virtual <a class="el" href="class_f_i_r_m_weight.html">FIRMWeight</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ab0119a577b6e1e150ccb79b532c5d595">generateEdgeControllerWithCost</a> (const Vertex a, const Vertex b, <a class="el" href="class_controller.html">EdgeControllerType</a> &amp;edgeController, const bool constructionMode=true)</td></tr>
<tr class="memdesc:ab0119a577b6e1e150ccb79b532c5d595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the cost of the edge. <br /></td></tr>
<tr class="separator:ab0119a577b6e1e150ccb79b532c5d595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9b9dc0d7f65a734766d49d2568c439"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a7d9b9dc0d7f65a734766d49d2568c439">generateEdgeController</a> (const ompl::base::State *start, ompl::base::State *target, <a class="el" href="class_controller.html">EdgeControllerType</a> &amp;edgeController)</td></tr>
<tr class="memdesc:a7d9b9dc0d7f65a734766d49d2568c439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an edge controller and loads the edge properties from XML.  <a href="#a7d9b9dc0d7f65a734766d49d2568c439">More...</a><br /></td></tr>
<tr class="separator:a7d9b9dc0d7f65a734766d49d2568c439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9061a8baf28a8a7192705a655394e68"><td class="memItemLeft" align="right" valign="top"><a id="af9061a8baf28a8a7192705a655394e68"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#af9061a8baf28a8a7192705a655394e68">generateNodeController</a> (ompl::base::State *state, <a class="el" href="class_controller.html">NodeControllerType</a> &amp;nodeController)</td></tr>
<tr class="memdesc:af9061a8baf28a8a7192705a655394e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the node controller that stabilizes the robot to the node and sets the stationary covariance at the node. <br /></td></tr>
<tr class="separator:af9061a8baf28a8a7192705a655394e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a2e9712ad77afccdfb6aba0af0ab0b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a86a2e9712ad77afccdfb6aba0af0ab0b">solveDynamicProgram</a> (const Vertex goalVertex, const bool reinit)</td></tr>
<tr class="memdesc:a86a2e9712ad77afccdfb6aba0af0ab0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the dynamic program to return a feedback policy.  <a href="#a86a2e9712ad77afccdfb6aba0af0ab0b">More...</a><br /></td></tr>
<tr class="separator:a86a2e9712ad77afccdfb6aba0af0ab0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37312889b7ab7782eae42e60aec8b887"><td class="memItemLeft" align="right" valign="top"><a id="a37312889b7ab7782eae42e60aec8b887"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a37312889b7ab7782eae42e60aec8b887">solveDijkstraSearch</a> (const Vertex goalVertex)</td></tr>
<tr class="memdesc:a37312889b7ab7782eae42e60aec8b887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves for a (shortest) feedback path tree using Dijkstra search. <br /></td></tr>
<tr class="separator:a37312889b7ab7782eae42e60aec8b887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955af3024989de7d6910897091c5b410"><td class="memItemLeft" align="right" valign="top">virtual Edge&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a955af3024989de7d6910897091c5b410">generateRolloutPolicy</a> (const Vertex currentVertex, const FIRM::Vertex goal)</td></tr>
<tr class="memdesc:a955af3024989de7d6910897091c5b410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the rollout policy.  <a href="#a955af3024989de7d6910897091c5b410">More...</a><br /></td></tr>
<tr class="separator:a955af3024989de7d6910897091c5b410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a01634a7798174fe165df31f51676b"><td class="memItemLeft" align="right" valign="top"><a id="ad0a01634a7798174fe165df31f51676b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ad0a01634a7798174fe165df31f51676b">updateEdgeCollisionCost</a> (Vertex currentVertex, Vertex goalVertex)</td></tr>
<tr class="memdesc:ad0a01634a7798174fe165df31f51676b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the collision costs for edge along policy from currentVertex to goal. <br /></td></tr>
<tr class="separator:ad0a01634a7798174fe165df31f51676b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b75dad1fb4c974e518e399e5c3981a"><td class="memItemLeft" align="right" valign="top"><a id="a66b75dad1fb4c974e518e399e5c3981a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a66b75dad1fb4c974e518e399e5c3981a">isFeedbackPolicyValid</a> (Vertex currentVertex, Vertex goalVertex, const bool reset=false)</td></tr>
<tr class="memdesc:a66b75dad1fb4c974e518e399e5c3981a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if policy from currentVertex to goal is collision free. <br /></td></tr>
<tr class="separator:a66b75dad1fb4c974e518e399e5c3981a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cfa79455257a2d3ad71a223366a33c"><td class="memItemLeft" align="right" valign="top"><a id="ac1cfa79455257a2d3ad71a223366a33c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addStateToVisualization</b> (const ompl::base::State *state)</td></tr>
<tr class="separator:ac1cfa79455257a2d3ad71a223366a33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9e316c11b1e2ff52b5ff65996d3a01"><td class="memItemLeft" align="right" valign="top"><a id="a8d9e316c11b1e2ff52b5ff65996d3a01"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sendFeedbackEdgesToViz</b> ()</td></tr>
<tr class="separator:a8d9e316c11b1e2ff52b5ff65996d3a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c28acaa03461e00d36327be6dae1479"><td class="memItemLeft" align="right" valign="top"><a id="a4c28acaa03461e00d36327be6dae1479"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a4c28acaa03461e00d36327be6dae1479">simulateKidnapping</a> ()</td></tr>
<tr class="memdesc:a4c28acaa03461e00d36327be6dae1479"><td class="mdescLeft">&#160;</td><td class="mdescRight">simulates a kidnapping, where the robot is disturbed to a random new location <br /></td></tr>
<tr class="separator:a4c28acaa03461e00d36327be6dae1479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028d35907dff71115003d1c74638b290"><td class="memItemLeft" align="right" valign="top"><a id="a028d35907dff71115003d1c74638b290"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a028d35907dff71115003d1c74638b290">detectKidnapping</a> (ompl::base::State *previousState, ompl::base::State *newState)</td></tr>
<tr class="memdesc:a028d35907dff71115003d1c74638b290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects whether the robot was kidnapped or not. <br /></td></tr>
<tr class="separator:a028d35907dff71115003d1c74638b290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9c8c2d00857070a6e0fcd4b0c3d293"><td class="memItemLeft" align="right" valign="top"><a id="aec9c8c2d00857070a6e0fcd4b0c3d293"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#aec9c8c2d00857070a6e0fcd4b0c3d293">recoverLostRobot</a> (ompl::base::State *recoveredState)</td></tr>
<tr class="memdesc:aec9c8c2d00857070a6e0fcd4b0c3d293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when robot is lost, uses multi-modal planner to recover true position of robot. <br /></td></tr>
<tr class="separator:aec9c8c2d00857070a6e0fcd4b0c3d293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45414f616df837521f08aa1bbcae6362"><td class="memItemLeft" align="right" valign="top"><a id="a45414f616df837521f08aa1bbcae6362"></a>
std::pair&lt; typename FIRM::Edge, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a45414f616df837521f08aa1bbcae6362">getUpdatedNodeCostToGo</a> (const Vertex node, const Vertex goal)</td></tr>
<tr class="memdesc:a45414f616df837521f08aa1bbcae6362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the new cost to go from a node. <br /></td></tr>
<tr class="separator:a45414f616df837521f08aa1bbcae6362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0967139a72d4d7a9190a50aefb3bb593"><td class="memItemLeft" align="right" valign="top"><a id="a0967139a72d4d7a9190a50aefb3bb593"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a0967139a72d4d7a9190a50aefb3bb593">sendMostLikelyPathToViz</a> (const Vertex start, const Vertex goal)</td></tr>
<tr class="memdesc:a0967139a72d4d7a9190a50aefb3bb593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the most likely path to visualizer based on start location. <br /></td></tr>
<tr class="separator:a0967139a72d4d7a9190a50aefb3bb593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c5cd9e0c7618758e1bd9ff0a7e604c"><td class="memItemLeft" align="right" valign="top"><a id="a66c5cd9e0c7618758e1bd9ff0a7e604c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a66c5cd9e0c7618758e1bd9ff0a7e604c">writeTimeSeriesDataToFile</a> (std::string fname, std::string dataName)</td></tr>
<tr class="memdesc:a66c5cd9e0c7618758e1bd9ff0a7e604c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a time series data to a file. <br /></td></tr>
<tr class="separator:a66c5cd9e0c7618758e1bd9ff0a7e604c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7b0eafa2589b9cfae28e478d77d51a"><td class="memItemLeft" align="right" valign="top"><a id="a2d7b0eafa2589b9cfae28e478d77d51a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a2d7b0eafa2589b9cfae28e478d77d51a">isStartVertex</a> (const Vertex v)</td></tr>
<tr class="memdesc:a2d7b0eafa2589b9cfae28e478d77d51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this vertex belongs to the list of start vertices. <br /></td></tr>
<tr class="separator:a2d7b0eafa2589b9cfae28e478d77d51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09d6e5ce04752ac6b16e1e59145cbed"><td class="memItemLeft" align="right" valign="top"><a id="ab09d6e5ce04752ac6b16e1e59145cbed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ab09d6e5ce04752ac6b16e1e59145cbed">isGoalVertex</a> (const Vertex v)</td></tr>
<tr class="memdesc:ab09d6e5ce04752ac6b16e1e59145cbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this vertex belongs to the list of goal vertices. <br /></td></tr>
<tr class="separator:ab09d6e5ce04752ac6b16e1e59145cbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3847c3baf1f549bb9270163e7a6365eb"><td class="memItemLeft" align="right" valign="top"><a id="a3847c3baf1f549bb9270163e7a6365eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a3847c3baf1f549bb9270163e7a6365eb">showRolloutConnections</a> (const Vertex v)</td></tr>
<tr class="memdesc:a3847c3baf1f549bb9270163e7a6365eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rollout connections to visualization. <br /></td></tr>
<tr class="separator:a3847c3baf1f549bb9270163e7a6365eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e63922880cb24e7feeb52c494a7b194"><td class="memItemLeft" align="right" valign="top"><a id="a0e63922880cb24e7feeb52c494a7b194"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a0e63922880cb24e7feeb52c494a7b194">evaluateSuccessProbability</a> (const Edge currentEdge, const Vertex start, const Vertex goal)</td></tr>
<tr class="memdesc:a0e63922880cb24e7feeb52c494a7b194"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the current success probability by multiplying the success probability of current edge and all future edges to goal vertex <br /></td></tr>
<tr class="separator:a0e63922880cb24e7feeb52c494a7b194"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a1381ddffa42b0bf2d36dc9c6d9d1da9d"><td class="memItemLeft" align="right" valign="top"><a id="a1381ddffa42b0bf2d36dc9c6d9d1da9d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a1381ddffa42b0bf2d36dc9c6d9d1da9d">starStrategy_</a></td></tr>
<tr class="memdesc:a1381ddffa42b0bf2d36dc9c6d9d1da9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating whether the default connection strategy is the Star strategy. <br /></td></tr>
<tr class="separator:a1381ddffa42b0bf2d36dc9c6d9d1da9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4307c058abb03b3a84c5c60e849c191"><td class="memItemLeft" align="right" valign="top"><a id="af4307c058abb03b3a84c5c60e849c191"></a>
ompl::base::ValidStateSamplerPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#af4307c058abb03b3a84c5c60e849c191">sampler_</a></td></tr>
<tr class="memdesc:af4307c058abb03b3a84c5c60e849c191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampler user for generating valid samples in the state space. <br /></td></tr>
<tr class="separator:af4307c058abb03b3a84c5c60e849c191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71a0e86b8a99f9eaa687f161d8d68e1"><td class="memItemLeft" align="right" valign="top"><a id="af71a0e86b8a99f9eaa687f161d8d68e1"></a>
ompl::base::StateSamplerPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#af71a0e86b8a99f9eaa687f161d8d68e1">simpleSampler_</a></td></tr>
<tr class="memdesc:af71a0e86b8a99f9eaa687f161d8d68e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampler user for generating random in the state space. <br /></td></tr>
<tr class="separator:af71a0e86b8a99f9eaa687f161d8d68e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed6858c0216ed9fc49f02e4aafc4443"><td class="memItemLeft" align="right" valign="top"><a id="aeed6858c0216ed9fc49f02e4aafc4443"></a>
RoadmapNeighbors&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#aeed6858c0216ed9fc49f02e4aafc4443">nn_</a></td></tr>
<tr class="memdesc:aeed6858c0216ed9fc49f02e4aafc4443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nearest neighbors data structure. <br /></td></tr>
<tr class="separator:aeed6858c0216ed9fc49f02e4aafc4443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac954812b235fc64b57ea319bec7c80bb"><td class="memItemLeft" align="right" valign="top"><a id="ac954812b235fc64b57ea319bec7c80bb"></a>
<a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ac954812b235fc64b57ea319bec7c80bb">g_</a></td></tr>
<tr class="memdesc:ac954812b235fc64b57ea319bec7c80bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connectivity graph. <br /></td></tr>
<tr class="separator:ac954812b235fc64b57ea319bec7c80bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333c7dec34b4c0977f85424b9fc3dc21"><td class="memItemLeft" align="right" valign="top"><a id="a333c7dec34b4c0977f85424b9fc3dc21"></a>
std::vector&lt; Vertex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a333c7dec34b4c0977f85424b9fc3dc21">startM_</a></td></tr>
<tr class="memdesc:a333c7dec34b4c0977f85424b9fc3dc21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of start milestones. <br /></td></tr>
<tr class="separator:a333c7dec34b4c0977f85424b9fc3dc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb59b6121e120e14f30c58e567ec6a4c"><td class="memItemLeft" align="right" valign="top"><a id="aeb59b6121e120e14f30c58e567ec6a4c"></a>
std::vector&lt; Vertex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#aeb59b6121e120e14f30c58e567ec6a4c">goalM_</a></td></tr>
<tr class="memdesc:aeb59b6121e120e14f30c58e567ec6a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of goal milestones. <br /></td></tr>
<tr class="separator:aeb59b6121e120e14f30c58e567ec6a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f27981600a6b5ee4c5124b8f9bc640b"><td class="memItemLeft" align="right" valign="top"><a id="a8f27981600a6b5ee4c5124b8f9bc640b"></a>
boost::property_map&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>, <a class="el" href="struct_f_i_r_m_1_1vertex__state__t.html">vertex_state_t</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a8f27981600a6b5ee4c5124b8f9bc640b">stateProperty_</a></td></tr>
<tr class="memdesc:a8f27981600a6b5ee4c5124b8f9bc640b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the internal ompl::base::state at each Vertex. <br /></td></tr>
<tr class="separator:a8f27981600a6b5ee4c5124b8f9bc640b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5651af4be68cf84115fbf6fe4b2c958d"><td class="memItemLeft" align="right" valign="top"><a id="a5651af4be68cf84115fbf6fe4b2c958d"></a>
boost::property_map&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>, <a class="el" href="struct_f_i_r_m_1_1vertex__total__connection__attempts__t.html">vertex_total_connection_attempts_t</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a5651af4be68cf84115fbf6fe4b2c958d">totalConnectionAttemptsProperty_</a></td></tr>
<tr class="memdesc:a5651af4be68cf84115fbf6fe4b2c958d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the number of total connection attempts for a vertex. <br /></td></tr>
<tr class="separator:a5651af4be68cf84115fbf6fe4b2c958d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d31e5b2a0bf5921fb1c8f43e55338b"><td class="memItemLeft" align="right" valign="top"><a id="ad9d31e5b2a0bf5921fb1c8f43e55338b"></a>
boost::property_map&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>, <a class="el" href="struct_f_i_r_m_1_1vertex__successful__connection__attempts__t.html">vertex_successful_connection_attempts_t</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ad9d31e5b2a0bf5921fb1c8f43e55338b">successfulConnectionAttemptsProperty_</a></td></tr>
<tr class="memdesc:ad9d31e5b2a0bf5921fb1c8f43e55338b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the number of successful connection attempts for a vertex. <br /></td></tr>
<tr class="separator:ad9d31e5b2a0bf5921fb1c8f43e55338b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe2eb302b9af9ced9bc26f03d369297"><td class="memItemLeft" align="right" valign="top"><a id="aebe2eb302b9af9ced9bc26f03d369297"></a>
boost::property_map&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>, boost::edge_weight_t &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#aebe2eb302b9af9ced9bc26f03d369297">weightProperty_</a></td></tr>
<tr class="memdesc:aebe2eb302b9af9ced9bc26f03d369297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the weights of each Edge. <br /></td></tr>
<tr class="separator:aebe2eb302b9af9ced9bc26f03d369297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81eba4eb39bce397127a9d41cf0b5cd2"><td class="memItemLeft" align="right" valign="top"><a id="a81eba4eb39bce397127a9d41cf0b5cd2"></a>
boost::property_map&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>, boost::edge_index_t &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a81eba4eb39bce397127a9d41cf0b5cd2">edgeIDProperty_</a></td></tr>
<tr class="memdesc:a81eba4eb39bce397127a9d41cf0b5cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the indices of each Edge. <br /></td></tr>
<tr class="separator:a81eba4eb39bce397127a9d41cf0b5cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe52d3e291fc164ff9338765534e7ce"><td class="memItemLeft" align="right" valign="top"><a id="adbe52d3e291fc164ff9338765534e7ce"></a>
boost::disjoint_sets&lt; boost::property_map&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>, boost::vertex_rank_t &gt;::type, boost::property_map&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>, boost::vertex_predecessor_t &gt;::type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#adbe52d3e291fc164ff9338765534e7ce">disjointSets_</a></td></tr>
<tr class="memdesc:adbe52d3e291fc164ff9338765534e7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure that maintains the connected components. <br /></td></tr>
<tr class="separator:adbe52d3e291fc164ff9338765534e7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517174c1ae349153df76f81f2ba2b2f1"><td class="memItemLeft" align="right" valign="top"><a id="a517174c1ae349153df76f81f2ba2b2f1"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a517174c1ae349153df76f81f2ba2b2f1">maxEdgeID_</a></td></tr>
<tr class="memdesc:a517174c1ae349153df76f81f2ba2b2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum unique id number used so for for edges. <br /></td></tr>
<tr class="separator:a517174c1ae349153df76f81f2ba2b2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcb0aef9c9101c4569f5b6bb5f576ae"><td class="memItemLeft" align="right" valign="top"><a id="a0fcb0aef9c9101c4569f5b6bb5f576ae"></a>
<a class="el" href="class_f_i_r_m.html#abf0ce9293fe4c9efb64248390a0e4e5b">ConnectionStrategy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a0fcb0aef9c9101c4569f5b6bb5f576ae">connectionStrategy_</a></td></tr>
<tr class="memdesc:a0fcb0aef9c9101c4569f5b6bb5f576ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that returns the milestones to attempt connections with. <br /></td></tr>
<tr class="separator:a0fcb0aef9c9101c4569f5b6bb5f576ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a93325399590bb6e9395b828ac93c58"><td class="memItemLeft" align="right" valign="top"><a id="a5a93325399590bb6e9395b828ac93c58"></a>
<a class="el" href="class_f_i_r_m.html#ad7e9eb1fa5c484b15234cc7b5e5d4e2f">KConnectionStrategy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a5a93325399590bb6e9395b828ac93c58">kConnectionStrategy_</a></td></tr>
<tr class="memdesc:a5a93325399590bb6e9395b828ac93c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Another function that returns the k-nearest neighbor milestones to attempt connections with. <br /></td></tr>
<tr class="separator:a5a93325399590bb6e9395b828ac93c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cc77417338d946478f5a71e6bd5b70"><td class="memItemLeft" align="right" valign="top"><a id="a42cc77417338d946478f5a71e6bd5b70"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a42cc77417338d946478f5a71e6bd5b70">userSetConnectionStrategy_</a></td></tr>
<tr class="memdesc:a42cc77417338d946478f5a71e6bd5b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating whether the employed connection strategy was set by the user (or defaults are assumed) <br /></td></tr>
<tr class="separator:a42cc77417338d946478f5a71e6bd5b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e91a5d8aba0ccaca892fb9eeda4ef41"><td class="memItemLeft" align="right" valign="top"><a id="a2e91a5d8aba0ccaca892fb9eeda4ef41"></a>
ompl::RNG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a2e91a5d8aba0ccaca892fb9eeda4ef41">rng_</a></td></tr>
<tr class="memdesc:a2e91a5d8aba0ccaca892fb9eeda4ef41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random number generator. <br /></td></tr>
<tr class="separator:a2e91a5d8aba0ccaca892fb9eeda4ef41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc413ddef9b66cd337c0e19c6ba79d84"><td class="memItemLeft" align="right" valign="top"><a id="afc413ddef9b66cd337c0e19c6ba79d84"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#afc413ddef9b66cd337c0e19c6ba79d84">addedSolution_</a></td></tr>
<tr class="memdesc:afc413ddef9b66cd337c0e19c6ba79d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flag indicating that a solution has been added during <a class="el" href="class_f_i_r_m.html#a02f3c98de4840594193ba5bf7ff3ca63" title="The key function that solves the planning problem. ">solve()</a> <br /></td></tr>
<tr class="separator:afc413ddef9b66cd337c0e19c6ba79d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71c316b447bb7b404dc27c8d673fd55"><td class="memItemLeft" align="right" valign="top"><a id="ae71c316b447bb7b404dc27c8d673fd55"></a>
boost::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ae71c316b447bb7b404dc27c8d673fd55">graphMutex_</a></td></tr>
<tr class="memdesc:ae71c316b447bb7b404dc27c8d673fd55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to guard access to the Graph member (g_) <br /></td></tr>
<tr class="separator:ae71c316b447bb7b404dc27c8d673fd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3628d68813a5a556a9ca1b55f36315cb"><td class="memItemLeft" align="right" valign="top"><a id="a3628d68813a5a556a9ca1b55f36315cb"></a>
firm::SpaceInformation::SpaceInformationPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a3628d68813a5a556a9ca1b55f36315cb">siF_</a></td></tr>
<tr class="memdesc:a3628d68813a5a556a9ca1b55f36315cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base::SpaceInformation cast as <a class="el" href="classfirm_1_1_space_information.html">firm::SpaceInformation</a>, for convenience. <br /></td></tr>
<tr class="separator:a3628d68813a5a556a9ca1b55f36315cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c508cb1c9346d2d5bc253e1621b798"><td class="memItemLeft" align="right" valign="top"><a id="a37c508cb1c9346d2d5bc253e1621b798"></a>
firm::SpaceInformation::SpaceInformationPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a37c508cb1c9346d2d5bc253e1621b798">policyExecutionSI_</a></td></tr>
<tr class="memdesc:a37c508cb1c9346d2d5bc253e1621b798"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the space in which the policy is executed. By default it is set to the same space that is passed to the constructer. If this space is changed, the observations and controls are both in the context of this new space. Use the setPolicyExecutionSpace function to change this parameter. Particularly useful if you wish to drive a real robot and get sensor readings. <br /></td></tr>
<tr class="separator:a37c508cb1c9346d2d5bc253e1621b798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfacc68b478054d0b99a3965d33d718a"><td class="memItemLeft" align="right" valign="top"><a id="abfacc68b478054d0b99a3965d33d718a"></a>
std::map&lt; Edge, <a class="el" href="class_controller.html">EdgeControllerType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#abfacc68b478054d0b99a3965d33d718a">edgeControllers_</a></td></tr>
<tr class="memdesc:abfacc68b478054d0b99a3965d33d718a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table that stores the edge controllers according to the edges. <br /></td></tr>
<tr class="separator:abfacc68b478054d0b99a3965d33d718a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80211b920fb34ee04779c9af2c0d1c4"><td class="memItemLeft" align="right" valign="top"><a id="ac80211b920fb34ee04779c9af2c0d1c4"></a>
std::map&lt; Vertex, <a class="el" href="class_controller.html">NodeControllerType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ac80211b920fb34ee04779c9af2c0d1c4">nodeControllers_</a></td></tr>
<tr class="memdesc:ac80211b920fb34ee04779c9af2c0d1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table that stores the node controllers according to the node (vertex) ids. <br /></td></tr>
<tr class="separator:ac80211b920fb34ee04779c9af2c0d1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da49edf6ea58f4116cd3c31022bd693"><td class="memItemLeft" align="right" valign="top"><a id="a2da49edf6ea58f4116cd3c31022bd693"></a>
std::map&lt; Vertex, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a2da49edf6ea58f4116cd3c31022bd693">costToGo_</a></td></tr>
<tr class="memdesc:a2da49edf6ea58f4116cd3c31022bd693"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table that stores the cost-to-go according to the node (vertex) ids. <br /></td></tr>
<tr class="separator:a2da49edf6ea58f4116cd3c31022bd693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0a180c88dedb6c1ad89802ecfe244f"><td class="memItemLeft" align="right" valign="top"><a id="a2e0a180c88dedb6c1ad89802ecfe244f"></a>
std::map&lt; Vertex, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a2e0a180c88dedb6c1ad89802ecfe244f">stationaryPenalties_</a></td></tr>
<tr class="memdesc:a2e0a180c88dedb6c1ad89802ecfe244f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table that stores the stationary penalty for rollout according to the node (vertex) ids. <br /></td></tr>
<tr class="separator:a2e0a180c88dedb6c1ad89802ecfe244f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913b68ee75d630f38cdd869fda9b4450"><td class="memItemLeft" align="right" valign="top"><a id="a913b68ee75d630f38cdd869fda9b4450"></a>
std::map&lt; Vertex, Vertex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a913b68ee75d630f38cdd869fda9b4450">bestChildVertexToGoal_</a></td></tr>
<tr class="memdesc:a913b68ee75d630f38cdd869fda9b4450"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table that stores the best child node (along the shortest path to the goal) according to the node (vertex) ids. <br /></td></tr>
<tr class="separator:a913b68ee75d630f38cdd869fda9b4450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9e2e83177ef121adc36ef7f9e5d16d"><td class="memItemLeft" align="right" valign="top"><a id="aae9e2e83177ef121adc36ef7f9e5d16d"></a>
std::map&lt; Vertex, Edge &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>feedback_</b></td></tr>
<tr class="separator:aae9e2e83177ef121adc36ef7f9e5d16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95d8eca7c4ed6936ed226d08f02b853"><td class="memItemLeft" align="right" valign="top"><a id="ac95d8eca7c4ed6936ed226d08f02b853"></a>
std::map&lt; Vertex, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>feedbackValid_</b></td></tr>
<tr class="separator:ac95d8eca7c4ed6936ed226d08f02b853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd1f931f2238c9fe025b3e2ba0513e2"><td class="memItemLeft" align="right" valign="top"><a id="a3cd1f931f2238c9fe025b3e2ba0513e2"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a3cd1f931f2238c9fe025b3e2ba0513e2">numMCParticles_</a></td></tr>
<tr class="memdesc:a3cd1f931f2238c9fe025b3e2ba0513e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of particles to use for monte carlo simulations. <br /></td></tr>
<tr class="separator:a3cd1f931f2238c9fe025b3e2ba0513e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9de6c5accdea0f9b6d1ff458350036"><td class="memItemLeft" align="right" valign="top"><a id="add9de6c5accdea0f9b6d1ff458350036"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#add9de6c5accdea0f9b6d1ff458350036">minFIRMNodes_</a></td></tr>
<tr class="memdesc:add9de6c5accdea0f9b6d1ff458350036"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum number of nodes that should be sampled. <br /></td></tr>
<tr class="separator:add9de6c5accdea0f9b6d1ff458350036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76b1515ae58649447f53870e4f19b43"><td class="memItemLeft" align="right" valign="top"><a id="ad76b1515ae58649447f53870e4f19b43"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ad76b1515ae58649447f53870e4f19b43">maxFIRMNodes_</a></td></tr>
<tr class="memdesc:ad76b1515ae58649447f53870e4f19b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of nodes that should be sampled. <br /></td></tr>
<tr class="separator:ad76b1515ae58649447f53870e4f19b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcb67a67bdcc9b4a625df981345c3b2"><td class="memItemLeft" align="right" valign="top"><a id="afbcb67a67bdcc9b4a625df981345c3b2"></a>
<a class="el" href="class_n_b_m3_p.html">NBM3P</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>policyGenerator_</b></td></tr>
<tr class="separator:afbcb67a67bdcc9b4a625df981345c3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba7b75c6e4a881c8639f6dc836b154c"><td class="memItemLeft" align="right" valign="top"><a id="aeba7b75c6e4a881c8639f6dc836b154c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>loadedRoadmapFromFile_</b></td></tr>
<tr class="separator:aeba7b75c6e4a881c8639f6dc836b154c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64580032f7517034b53e49502685196d"><td class="memItemLeft" align="right" valign="top"><a id="a64580032f7517034b53e49502685196d"></a>
std::vector&lt; std::pair&lt; std::pair&lt; int, int &gt;, <a class="el" href="class_f_i_r_m_weight.html">FIRMWeight</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>loadedEdgeProperties_</b></td></tr>
<tr class="separator:a64580032f7517034b53e49502685196d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d99f5f4a17a52269b8d36e906cebadb"><td class="memItemLeft" align="right" valign="top"><a id="a6d99f5f4a17a52269b8d36e906cebadb"></a>
ompl::base::State *&#160;</td><td class="memItemRight" valign="bottom"><b>kidnappedState_</b></td></tr>
<tr class="separator:a6d99f5f4a17a52269b8d36e906cebadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c94459da188e0cd1a2a2392bb9df605"><td class="memItemLeft" align="right" valign="top"><a id="a2c94459da188e0cd1a2a2392bb9df605"></a>
std::vector&lt; std::tuple&lt; int, float, float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>costHistory_</b></td></tr>
<tr class="separator:a2c94459da188e0cd1a2a2392bb9df605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b1115c3ab7a0e4069be33b9c990592"><td class="memItemLeft" align="right" valign="top"><a id="ae5b1115c3ab7a0e4069be33b9c990592"></a>
std::vector&lt; std::pair&lt; int, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>successProbabilityHistory_</b></td></tr>
<tr class="separator:ae5b1115c3ab7a0e4069be33b9c990592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157e610a2e7ebd1462f759b95807bcfa"><td class="memItemLeft" align="right" valign="top"><a id="a157e610a2e7ebd1462f759b95807bcfa"></a>
std::vector&lt; std::pair&lt; int, std::vector&lt; float &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>weightsHistory_</b></td></tr>
<tr class="separator:a157e610a2e7ebd1462f759b95807bcfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20d0c5df78982bdbf600cf79be3fcb5"><td class="memItemLeft" align="right" valign="top"><a id="ae20d0c5df78982bdbf600cf79be3fcb5"></a>
std::vector&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nodeReachedHistory_</b></td></tr>
<tr class="separator:ae20d0c5df78982bdbf600cf79be3fcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3c0b7103ec15443c8b29fcadac96e3"><td class="memItemLeft" align="right" valign="top"><a id="a6e3c0b7103ec15443c8b29fcadac96e3"></a>
std::vector&lt; std::pair&lt; int, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>velocityHistory_</b></td></tr>
<tr class="separator:a6e3c0b7103ec15443c8b29fcadac96e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa017748148fb7c1825db2b3e57e91c45"><td class="memItemLeft" align="right" valign="top"><a id="aa017748148fb7c1825db2b3e57e91c45"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>currentTimeStep_</b></td></tr>
<tr class="separator:aa017748148fb7c1825db2b3e57e91c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7aa20ab462a1b4403b79e3f99d891b3"><td class="memItemLeft" align="right" valign="top"><a id="aa7aa20ab462a1b4403b79e3f99d891b3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>executionCostCov_</b></td></tr>
<tr class="separator:aa7aa20ab462a1b4403b79e3f99d891b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9f93a4a345101aca1075401232614e"><td class="memItemLeft" align="right" valign="top"><a id="aac9f93a4a345101aca1075401232614e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>executionCost_</b></td></tr>
<tr class="separator:aac9f93a4a345101aca1075401232614e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac337657961cddb797ba25f2f8d4caec7"><td class="memItemLeft" align="right" valign="top"><a id="ac337657961cddb797ba25f2f8d4caec7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numberofNodesReached_</b></td></tr>
<tr class="separator:ac337657961cddb797ba25f2f8d4caec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74aa3cac6147c8c82a80a5227f712b8e"><td class="memItemLeft" align="right" valign="top"><a id="a74aa3cac6147c8c82a80a5227f712b8e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numberOfStationaryPenalizedNodes_</b></td></tr>
<tr class="separator:a74aa3cac6147c8c82a80a5227f712b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ae2c267d04daac976ec83eac4b1527"><td class="memItemLeft" align="right" valign="top"><a id="a38ae2c267d04daac976ec83eac4b1527"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>sumOfStationaryPenalties_</b></td></tr>
<tr class="separator:a38ae2c267d04daac976ec83eac4b1527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b9e30be1c33e1cee45f3e2d9bffdf1"><td class="memItemLeft" align="right" valign="top"><a id="a07b9e30be1c33e1cee45f3e2d9bffdf1"></a>
std::vector&lt; std::tuple&lt; int, int, float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>stationaryPenaltyHistory_</b></td></tr>
<tr class="separator:a07b9e30be1c33e1cee45f3e2d9bffdf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963519ae960aa0f5979c19055b488004"><td class="memItemLeft" align="right" valign="top"><a id="a963519ae960aa0f5979c19055b488004"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a963519ae960aa0f5979c19055b488004">logFilePath_</a></td></tr>
<tr class="memdesc:a963519ae960aa0f5979c19055b488004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path to where log files will be stored. <br /></td></tr>
<tr class="separator:a963519ae960aa0f5979c19055b488004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2a227297915f571bcd23c7dab6ec76"><td class="memItemLeft" align="right" valign="top"><a id="a9d2a227297915f571bcd23c7dab6ec76"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a9d2a227297915f571bcd23c7dab6ec76">doSavePlannerData_</a></td></tr>
<tr class="memdesc:a9d2a227297915f571bcd23c7dab6ec76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to save roadmap or not. <br /></td></tr>
<tr class="separator:a9d2a227297915f571bcd23c7dab6ec76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f273a0600b7e634713c45ea67b7c45"><td class="memItemLeft" align="right" valign="top"><a id="a84f273a0600b7e634713c45ea67b7c45"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a84f273a0600b7e634713c45ea67b7c45">doSaveLogs_</a></td></tr>
<tr class="memdesc:a84f273a0600b7e634713c45ea67b7c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to save run time simulation logs or not. <br /></td></tr>
<tr class="separator:a84f273a0600b7e634713c45ea67b7c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b0b320cfcbc6a68fac864433efd61a"><td class="memItemLeft" align="right" valign="top"><a id="ac8b0b320cfcbc6a68fac864433efd61a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ac8b0b320cfcbc6a68fac864433efd61a">doSaveVideo_</a></td></tr>
<tr class="memdesc:ac8b0b320cfcbc6a68fac864433efd61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to save video. <br /></td></tr>
<tr class="separator:ac8b0b320cfcbc6a68fac864433efd61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3c362af8a293d7384b0b948df500dc"><td class="memItemLeft" align="right" valign="top"><a id="a7d3c362af8a293d7384b0b948df500dc"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>NNRadius_</b></td></tr>
<tr class="separator:a7d3c362af8a293d7384b0b948df500dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f541a5acb40719e720b6620c702869"><td class="memItemLeft" align="right" valign="top"><a id="ae0f541a5acb40719e720b6620c702869"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numNearestNeighbors_</b></td></tr>
<tr class="separator:ae0f541a5acb40719e720b6620c702869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428e77447ed08f1ca0a44790ff7f1650"><td class="memItemLeft" align="right" valign="top"><a id="a428e77447ed08f1ca0a44790ff7f1650"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>rolloutSteps_</b></td></tr>
<tr class="separator:a428e77447ed08f1ca0a44790ff7f1650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f974c8fd05933d5c4c74334cb1b0349"><td class="memItemLeft" align="right" valign="top"><a id="a1f974c8fd05933d5c4c74334cb1b0349"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>discountFactorDP_</b></td></tr>
<tr class="separator:a1f974c8fd05933d5c4c74334cb1b0349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6826ed64123a487786b878f456f54e20"><td class="memItemLeft" align="right" valign="top"><a id="a6826ed64123a487786b878f456f54e20"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>distanceCostWeight_</b></td></tr>
<tr class="separator:a6826ed64123a487786b878f456f54e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7b72a105941dc3df0e20bbaacdc972"><td class="memItemLeft" align="right" valign="top"><a id="afa7b72a105941dc3df0e20bbaacdc972"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>connectToFutureNodes_</b></td></tr>
<tr class="separator:afa7b72a105941dc3df0e20bbaacdc972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467ffe50acca3f4f384457cea9369f4a"><td class="memItemLeft" align="right" valign="top"><a id="a467ffe50acca3f4f384457cea9369f4a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>applyStationaryPenalty_</b></td></tr>
<tr class="separator:a467ffe50acca3f4f384457cea9369f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd4625905c4b43583aa9ce0d5666854"><td class="memItemLeft" align="right" valign="top"><a id="a8dd4625905c4b43583aa9ce0d5666854"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>borderBeliefSampling_</b></td></tr>
<tr class="separator:a8dd4625905c4b43583aa9ce0d5666854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf9bae73d74b418c305b4b6f48ce3eb"><td class="memItemLeft" align="right" valign="top"><a id="abaf9bae73d74b418c305b4b6f48ce3eb"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>informationCostWeight_</b></td></tr>
<tr class="separator:abaf9bae73d74b418c305b4b6f48ce3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad284d3b21918bafcd8dbfa98568914d1"><td class="memItemLeft" align="right" valign="top"><a id="ad284d3b21918bafcd8dbfa98568914d1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>timeCostWeight_</b></td></tr>
<tr class="separator:ad284d3b21918bafcd8dbfa98568914d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e806f853dd1939aee7242d0a792abf"><td class="memItemLeft" align="right" valign="top"><a id="a43e806f853dd1939aee7242d0a792abf"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>statCostIncrement_</b></td></tr>
<tr class="separator:a43e806f853dd1939aee7242d0a792abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ffa25d0264784c920f284cf6dfb8fab"><td class="memItemLeft" align="right" valign="top"><a id="a8ffa25d0264784c920f284cf6dfb8fab"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>goalCostToGo_</b></td></tr>
<tr class="separator:a8ffa25d0264784c920f284cf6dfb8fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c60aa13a72fdf8683eec40e99a88f0"><td class="memItemLeft" align="right" valign="top"><a id="a04c60aa13a72fdf8683eec40e99a88f0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>obstacleCostToGo_</b></td></tr>
<tr class="separator:a04c60aa13a72fdf8683eec40e99a88f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b8390c653a99054e76dd27d83e7999"><td class="memItemLeft" align="right" valign="top"><a id="a15b8390c653a99054e76dd27d83e7999"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>initialCostToGo_</b></td></tr>
<tr class="separator:a15b8390c653a99054e76dd27d83e7999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f235887a1969172131706b8e068273f"><td class="memItemLeft" align="right" valign="top"><a id="a7f235887a1969172131706b8e068273f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>infiniteCostToGo_</b></td></tr>
<tr class="separator:a7f235887a1969172131706b8e068273f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599b177deaaf2ac507b19748d3212eb7"><td class="memItemLeft" align="right" valign="top"><a id="a599b177deaaf2ac507b19748d3212eb7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>maxDPIterations_</b></td></tr>
<tr class="separator:a599b177deaaf2ac507b19748d3212eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e0678de88ff1f54387f85b2dfd350c"><td class="memItemLeft" align="right" valign="top"><a id="a39e0678de88ff1f54387f85b2dfd350c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>convergenceThresholdDP_</b></td></tr>
<tr class="separator:a39e0678de88ff1f54387f85b2dfd350c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bf9384cc4d0b2e0847c8d74d6fe34c"><td class="memItemLeft" align="right" valign="top"><a id="aa3bf9384cc4d0b2e0847c8d74d6fe34c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numberOfTargetsInHistory_</b></td></tr>
<tr class="separator:aa3bf9384cc4d0b2e0847c8d74d6fe34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb89e5ea0811d151c8e1a43b6aa8aec3"><td class="memItemLeft" align="right" valign="top"><a id="adb89e5ea0811d151c8e1a43b6aa8aec3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numberOfFeedbackLookAhead_</b></td></tr>
<tr class="separator:adb89e5ea0811d151c8e1a43b6aa8aec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Feedback Information RoadMap planner. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a20f301d4dc3945deb4d14f36d39bacfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f301d4dc3945deb4d14f36d39bacfd">&#9670;&nbsp;</a></span>FilterType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_extended_k_f.html">ExtendedKF</a> <a class="el" href="class_f_i_r_m.html#a20f301d4dc3945deb4d14f36d39bacfd">FIRM::FilterType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defining the filter type depending on your problem </p>

</div>
</div>
<a id="a687e9f4243b22c30ee1fa5da22a85053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687e9f4243b22c30ee1fa5da22a85053">&#9670;&nbsp;</a></span>Graph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::adjacency_list&lt; boost::vecS, boost::vecS, boost::bidirectionalS, boost::property &lt; <a class="el" href="struct_f_i_r_m_1_1vertex__state__t.html">vertex_state_t</a>, ompl::base::State*, boost::property &lt; <a class="el" href="struct_f_i_r_m_1_1vertex__total__connection__attempts__t.html">vertex_total_connection_attempts_t</a>, unsigned int, boost::property &lt; <a class="el" href="struct_f_i_r_m_1_1vertex__successful__connection__attempts__t.html">vertex_successful_connection_attempts_t</a>, unsigned int, boost::property &lt; <a class="el" href="struct_f_i_r_m_1_1vertex__flags__t.html">vertex_flags_t</a>, unsigned int, boost::property &lt; boost::vertex_predecessor_t, unsigned long int, boost::property &lt; boost::vertex_rank_t, unsigned long int &gt; &gt; &gt; &gt; &gt; &gt;, boost::property &lt; boost::edge_weight_t, <a class="el" href="class_f_i_r_m_weight.html">FIRMWeight</a> , boost::property &lt; boost::edge_index_t, unsigned int, boost::property &lt; <a class="el" href="struct_f_i_r_m_1_1edge__flags__t.html">edge_flags_t</a>, unsigned int &gt; &gt; &gt; &gt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">FIRM::Graph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The underlying roadmap graph. </p>
<dl class="section user"><dt>Edges are directed and have a weight property called FIRMWeight. This weight property</dt><dd>stores information about the edge controller identification, transition probability and execution cost. </dd></dl>

</div>
</div>
<a id="a51f42e7d6bfd259ff5998083e02af08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f42e7d6bfd259ff5998083e02af08a">&#9670;&nbsp;</a></span>SeparatedControllerType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_r_h_c_i_create.html">RHCICreate</a> <a class="el" href="class_f_i_r_m.html#a51f42e7d6bfd259ff5998083e02af08a">FIRM::SeparatedControllerType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defining the separated controller types depending on your problem </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afbcd92332a3e7658e6f81f86b0883ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbcd92332a3e7658e6f81f86b0883ed0">&#9670;&nbsp;</a></span>executeFeedbackWithKidnapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FIRM::executeFeedbackWithKidnapping </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the generated policy on the system with kidnapping in the middle of a run. </p>
<ol type="1">
<li>Check if innovation i.e. change in trace(cov) between start and end state is high</li>
<li>If the change is high, then switch to lost mode</li>
<li>Sample modes and run policygen till you converge to one mode</li>
<li>get back to policy execution</li>
</ol>

</div>
</div>
<a id="a8267860838552b5b433212f142270615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8267860838552b5b433212f142270615">&#9670;&nbsp;</a></span>executeFeedbackWithRollout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FIRM::executeFeedbackWithRollout </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the rollout policy algorithm (See ICRA '14 paper) </p>
<p>Instead of executing the entire controller, we need to execute N steps, then calculate the cost to go through the neighboring nodes. Whichever gives the lowest cost to go, is our new path. Do this at every N steps.</p>

</div>
</div>
<a id="a7d9b9dc0d7f65a734766d49d2568c439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d9b9dc0d7f65a734766d49d2568c439">&#9670;&nbsp;</a></span>generateEdgeController()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FIRM::generateEdgeController </td>
          <td>(</td>
          <td class="paramtype">const ompl::base::State *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ompl::base::State *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_controller.html">FIRM::EdgeControllerType</a> &amp;&#160;</td>
          <td class="paramname"><em>edgeController</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates an edge controller and loads the edge properties from XML. </p>
<p>Generates the edge controller that drives the robot from start to end of edge </p>

</div>
</div>
<a id="a955af3024989de7d6910897091c5b410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955af3024989de7d6910897091c5b410">&#9670;&nbsp;</a></span>generateRolloutPolicy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FIRM::Edge FIRM::generateRolloutPolicy </td>
          <td>(</td>
          <td class="paramtype">const Vertex&#160;</td>
          <td class="paramname"><em>currentVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FIRM::Vertex&#160;</td>
          <td class="paramname"><em>goal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the rollout policy. </p>
<p>For the given node, find the out edges and see the total cost of taking that edge The cost of taking the edge is cost to go from the target of the edge + the cost of the edge itself</p>

<p>Reimplemented in <a class="el" href="class_f_i_r_m_c_p.html#a44ff1ee952f41da37a7108a1c707f0e4">FIRMCP</a>.</p>

</div>
</div>
<a id="a09a7ff97d8202a82ca7f6dddfd7ba185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a7ff97d8202a82ca7f6dddfd7ba185">&#9670;&nbsp;</a></span>setProblemDefinition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FIRM::setProblemDefinition </td>
          <td>(</td>
          <td class="paramtype">const ompl::base::ProblemDefinitionPtr &amp;&#160;</td>
          <td class="paramname"><em>pdef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the connection strategy function that specifies the milestones that connection attempts will be made to for a given milestone. </p>
<dl class="section user"><dt>The behavior and performance of PRM can be changed drastically</dt><dd>by varying the number and properties of the milestones that are connected to each other.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdef</td><td>A function that takes a milestone as an argument and returns a collection of other milestones to which a connection attempt must be made. The default connection strategy is to connect a milestone's 10 closest neighbors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86a2e9712ad77afccdfb6aba0af0ab0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a2e9712ad77afccdfb6aba0af0ab0b">&#9670;&nbsp;</a></span>solveDynamicProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FIRM::solveDynamicProgram </td>
          <td>(</td>
          <td class="paramtype">const Vertex&#160;</td>
          <td class="paramname"><em>goalVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>reinit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves the dynamic program to return a feedback policy. </p>
<p>&ndash;NOTES&ndash; Assign a high cost to go initially for all nodes that are not in the goal connected component. For nodes that are in the goal cc, we assign goal cost to go for the goal and init cost to go for all other nodes.</p>

</div>
</div>
<a id="a34535f25e4f3fb645fb65d57e3faf01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34535f25e4f3fb645fb65d57e3faf01b">&#9670;&nbsp;</a></span>uniteComponents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FIRM::uniteComponents </td>
          <td>(</td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a state from XML and add to Graph. </p>
<p>Make two milestones (<em>m1</em> and <em>m2</em>) be part of the same connected component. The component with fewer elements will get the id of the component with more elements. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/redwan/POMDP/FIRM/edpl-ompl/include/Planner/<a class="el" href="_f_i_r_m_8h_source.html">FIRM.h</a></li>
<li>/home/redwan/POMDP/FIRM/edpl-ompl/src/Planner/FIRM.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 8 2019 11:17:33 for EDPL-OMPL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
