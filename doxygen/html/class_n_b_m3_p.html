<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EDPL-OMPL: NBM3P Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EDPL-OMPL
   &#160;<span id="projectnumber">0.4</span>
   </div>
   <div id="projectbrief">TAMU</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_n_b_m3_p-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">NBM3P Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_n_b_m3_p_8h_source.html">NBM3P.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_n_b_m3_p_1_1vertex__state__t.html">vertex_state_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af8678f7970fe5eac1c12030c711f927f"><td class="memItemLeft" align="right" valign="top"><a id="af8678f7970fe5eac1c12030c711f927f"></a>
typedef boost::adjacency_list&lt; boost::vecS, boost::vecS, boost::undirectedS, boost::property&lt; <a class="el" href="struct_n_b_m3_p_1_1vertex__state__t.html">vertex_state_t</a>, ompl::base::State * &gt;, boost::property&lt; boost::edge_weight_t, unsigned int, boost::property&lt; boost::edge_index_t, unsigned int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Graph</b></td></tr>
<tr class="separator:af8678f7970fe5eac1c12030c711f927f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa54d5497edf2fcc353fd0b925282cc"><td class="memItemLeft" align="right" valign="top"><a id="adaa54d5497edf2fcc353fd0b925282cc"></a>
typedef boost::graph_traits&lt; Graph &gt;::vertex_descriptor&#160;</td><td class="memItemRight" valign="bottom"><b>Vertex</b></td></tr>
<tr class="separator:adaa54d5497edf2fcc353fd0b925282cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3a2429dc0c4aaa965db2b09629d59a"><td class="memItemLeft" align="right" valign="top"><a id="a1c3a2429dc0c4aaa965db2b09629d59a"></a>
typedef boost::graph_traits&lt; Graph &gt;::edge_descriptor&#160;</td><td class="memItemRight" valign="bottom"><b>Edge</b></td></tr>
<tr class="separator:a1c3a2429dc0c4aaa965db2b09629d59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805027e0ece50d49d31d64e7d8b9be64"><td class="memItemLeft" align="right" valign="top"><a id="a805027e0ece50d49d31d64e7d8b9be64"></a>
typedef std::shared_ptr&lt; ompl::NearestNeighbors&lt; Vertex &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RoadmapNeighbors</b></td></tr>
<tr class="separator:a805027e0ece50d49d31d64e7d8b9be64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a703b5d47928ffb674053cf2976cbb525"><td class="memItemLeft" align="right" valign="top"><a id="a703b5d47928ffb674053cf2976cbb525"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a703b5d47928ffb674053cf2976cbb525">NBM3P</a> (firm::SpaceInformation::SpaceInformationPtr si)</td></tr>
<tr class="memdesc:a703b5d47928ffb674053cf2976cbb525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a703b5d47928ffb674053cf2976cbb525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7559518458faed268cc7bdfe17e2b8fe"><td class="memItemLeft" align="right" valign="top"><a id="a7559518458faed268cc7bdfe17e2b8fe"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a7559518458faed268cc7bdfe17e2b8fe">~NBM3P</a> ()</td></tr>
<tr class="memdesc:a7559518458faed268cc7bdfe17e2b8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a7559518458faed268cc7bdfe17e2b8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c2f81984f30c6f129d3384420ec1ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a50c2f81984f30c6f129d3384420ec1ff">sampleNewBeliefStates</a> ()</td></tr>
<tr class="memdesc:a50c2f81984f30c6f129d3384420ec1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function samples the beliefs, which form the starting point for the multi-modal scenario.  <a href="#a50c2f81984f30c6f129d3384420ec1ff">More...</a><br /></td></tr>
<tr class="separator:a50c2f81984f30c6f129d3384420ec1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fc47d07d161a89fdc1bb8d97a82c86"><td class="memItemLeft" align="right" valign="top"><a id="af7fc47d07d161a89fdc1bb8d97a82c86"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#af7fc47d07d161a89fdc1bb8d97a82c86">distanceFunction</a> (const Vertex a, const Vertex b) const</td></tr>
<tr class="memdesc:af7fc47d07d161a89fdc1bb8d97a82c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute distance between two milestones (this is simply distance between the states of the milestones) <br /></td></tr>
<tr class="separator:af7fc47d07d161a89fdc1bb8d97a82c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b88433b0bff41c810a5a57c2fd0c38"><td class="memItemLeft" align="right" valign="top"><a id="a02b88433b0bff41c810a5a57c2fd0c38"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a02b88433b0bff41c810a5a57c2fd0c38">setCurrentBeliefStates</a> (const std::vector&lt; ompl::base::State *&gt; states)</td></tr>
<tr class="memdesc:a02b88433b0bff41c810a5a57c2fd0c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current belief states based on robot's belief states. <br /></td></tr>
<tr class="separator:a02b88433b0bff41c810a5a57c2fd0c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7a27824bfee181b766c393740d1a10"><td class="memItemLeft" align="right" valign="top"><a id="a5c7a27824bfee181b766c393740d1a10"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a5c7a27824bfee181b766c393740d1a10">addFIRMNodeToObservationGraph</a> (ompl::base::State *state)</td></tr>
<tr class="memdesc:a5c7a27824bfee181b766c393740d1a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the <a class="el" href="class_f_i_r_m.html" title="Feedback Information RoadMap planner. ">FIRM</a> node as a state to the observation graph. <br /></td></tr>
<tr class="separator:a5c7a27824bfee181b766c393740d1a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bfff53c3b1ddb0c6ef167da91a95a8"><td class="memItemLeft" align="right" valign="top"><a id="af0bfff53c3b1ddb0c6ef167da91a95a8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#af0bfff53c3b1ddb0c6ef167da91a95a8">setBeliefTargetStates</a> (const std::vector&lt; ompl::base::State *&gt; states)</td></tr>
<tr class="memdesc:af0bfff53c3b1ddb0c6ef167da91a95a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each belief state, there is a target node to go to, set those here. <br /></td></tr>
<tr class="separator:af0bfff53c3b1ddb0c6ef167da91a95a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad7379ed7dc0d3f4860d4a363aedafd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#acad7379ed7dc0d3f4860d4a363aedafd">getCurrentBeliefStates</a> (std::vector&lt; ompl::base::State *&gt; &amp;states)</td></tr>
<tr class="separator:acad7379ed7dc0d3f4860d4a363aedafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab500013db983e25a2b81fd8ee48ff428"><td class="memItemLeft" align="right" valign="top"><a id="ab500013db983e25a2b81fd8ee48ff428"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#ab500013db983e25a2b81fd8ee48ff428">clearInternalStates</a> ()</td></tr>
<tr class="memdesc:ab500013db983e25a2b81fd8ee48ff428"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear out the internal state containers <br /></td></tr>
<tr class="separator:ab500013db983e25a2b81fd8ee48ff428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5073bfd28c8e31f508a52f848b6ac1b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#ab5073bfd28c8e31f508a52f848b6ac1b">generatePolicy</a> (std::vector&lt; ompl::control::Control *&gt; &amp;policy)</td></tr>
<tr class="memdesc:ab5073bfd28c8e31f508a52f848b6ac1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the current belief states and target states, output the best policy.  <a href="#ab5073bfd28c8e31f508a52f848b6ac1b">More...</a><br /></td></tr>
<tr class="separator:ab5073bfd28c8e31f508a52f848b6ac1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8070db8f34e54556aef56f221c7f5b4d"><td class="memItemLeft" align="right" valign="top">virtual ompl::base::Cost&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a8070db8f34e54556aef56f221c7f5b4d">executeOpenLoopPolicyOnMode</a> (std::vector&lt; ompl::control::Control *&gt; controls, const ompl::base::State *state)</td></tr>
<tr class="memdesc:a8070db8f34e54556aef56f221c7f5b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the open loop policy on a given mode and outputs the cost.  <a href="#a8070db8f34e54556aef56f221c7f5b4d">More...</a><br /></td></tr>
<tr class="separator:a8070db8f34e54556aef56f221c7f5b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe6965cf94e0e48752c831d9d8210af"><td class="memItemLeft" align="right" valign="top"><a id="aabe6965cf94e0e48752c831d9d8210af"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#aabe6965cf94e0e48752c831d9d8210af">propagateBeliefs</a> (const ompl::control::Control *control, bool isSimulation=false)</td></tr>
<tr class="memdesc:aabe6965cf94e0e48752c831d9d8210af"><td class="mdescLeft">&#160;</td><td class="mdescRight">advances the beliefs/modes by applying the given controls <br /></td></tr>
<tr class="separator:aabe6965cf94e0e48752c831d9d8210af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8b1005e96ba553bc5726f4b29c79c1"><td class="memItemLeft" align="right" valign="top"><a id="a9b8b1005e96ba553bc5726f4b29c79c1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a9b8b1005e96ba553bc5726f4b29c79c1">updateWeights</a> (const arma::colvec trueObservation)</td></tr>
<tr class="memdesc:a9b8b1005e96ba553bc5726f4b29c79c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the weights of the Gaussians in the mixture. <br /></td></tr>
<tr class="separator:a9b8b1005e96ba553bc5726f4b29c79c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700d3b88a1868771feea8006cc5ce67d"><td class="memItemLeft" align="right" valign="top"><a id="a700d3b88a1868771feea8006cc5ce67d"></a>
virtual arma::colvec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a700d3b88a1868771feea8006cc5ce67d">computeInnovation</a> (const int currentBeliefIndx, const arma::colvec trueObservation, double &amp;weightFactor)</td></tr>
<tr class="memdesc:a700d3b88a1868771feea8006cc5ce67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the innovation between the robot's and mode's observation. <br /></td></tr>
<tr class="separator:a700d3b88a1868771feea8006cc5ce67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a66c1007c83f91c73d80ac2b5e7bdbf"><td class="memItemLeft" align="right" valign="top"><a id="a1a66c1007c83f91c73d80ac2b5e7bdbf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a1a66c1007c83f91c73d80ac2b5e7bdbf">removeBeliefs</a> (const std::vector&lt; int &gt; Indxs)</td></tr>
<tr class="memdesc:a1a66c1007c83f91c73d80ac2b5e7bdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove modes that are no longer considered important. <br /></td></tr>
<tr class="separator:a1a66c1007c83f91c73d80ac2b5e7bdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b4f462e0fbacef066d40c1bf479068"><td class="memItemLeft" align="right" valign="top"><a id="aa0b4f462e0fbacef066d40c1bf479068"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#aa0b4f462e0fbacef066d40c1bf479068">printWeights</a> () const</td></tr>
<tr class="memdesc:aa0b4f462e0fbacef066d40c1bf479068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the mode weights. <br /></td></tr>
<tr class="separator:aa0b4f462e0fbacef066d40c1bf479068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe00e2b04b4c6545ec87eb4d569fa068"><td class="memItemLeft" align="right" valign="top"><a id="abe00e2b04b4c6545ec87eb4d569fa068"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#abe00e2b04b4c6545ec87eb4d569fa068">isConverged</a> ()</td></tr>
<tr class="memdesc:abe00e2b04b4c6545ec87eb4d569fa068"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the beliefs have converged <br /></td></tr>
<tr class="separator:abe00e2b04b4c6545ec87eb4d569fa068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044d5ea04e213cfba2dc959cfa0edb78"><td class="memItemLeft" align="right" valign="top"><a id="a044d5ea04e213cfba2dc959cfa0edb78"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a044d5ea04e213cfba2dc959cfa0edb78">areCurrentBeliefsValid</a> ()</td></tr>
<tr class="memdesc:a044d5ea04e213cfba2dc959cfa0edb78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all beliefs are valid i.e. collision free. <br /></td></tr>
<tr class="separator:a044d5ea04e213cfba2dc959cfa0edb78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238cac66753c87ac21ddea6098b2c744"><td class="memItemLeft" align="right" valign="top"><a id="a238cac66753c87ac21ddea6098b2c744"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a238cac66753c87ac21ddea6098b2c744">doCurrentBeliefsSatisfyClearance</a> (int currentStep)</td></tr>
<tr class="memdesc:a238cac66753c87ac21ddea6098b2c744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all beliefs satisfy a certain minimum clearance for n steps from now, else false. <br /></td></tr>
<tr class="separator:a238cac66753c87ac21ddea6098b2c744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d71409b690633e8090f1333d4ef701"><td class="memItemLeft" align="right" valign="top"><a id="a99d71409b690633e8090f1333d4ef701"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a99d71409b690633e8090f1333d4ef701">getStateWithMaxWeight</a> (ompl::base::State *state, float &amp;weight)</td></tr>
<tr class="memdesc:a99d71409b690633e8090f1333d4ef701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the state with the max weight and its weight. <br /></td></tr>
<tr class="separator:a99d71409b690633e8090f1333d4ef701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e2fe76004cd269d07d94ae5f115b5d"><td class="memItemLeft" align="right" valign="top"><a id="ab4e2fe76004cd269d07d94ae5f115b5d"></a>
std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#ab4e2fe76004cd269d07d94ae5f115b5d">getWeights</a> ()</td></tr>
<tr class="memdesc:ab4e2fe76004cd269d07d94ae5f115b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the weights of the modes. <br /></td></tr>
<tr class="separator:ab4e2fe76004cd269d07d94ae5f115b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b33685661e5c331b55e115c3428fdb4"><td class="memItemLeft" align="right" valign="top"><a id="a2b33685661e5c331b55e115c3428fdb4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a2b33685661e5c331b55e115c3428fdb4">getNumberOfModes</a> ()</td></tr>
<tr class="memdesc:a2b33685661e5c331b55e115c3428fdb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the numbder of modes currently alive. <br /></td></tr>
<tr class="separator:a2b33685661e5c331b55e115c3428fdb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e376e8a18712fffcb72e9f5ef05746"><td class="memItemLeft" align="right" valign="top"><a id="a48e376e8a18712fffcb72e9f5ef05746"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a48e376e8a18712fffcb72e9f5ef05746">setPolicyExecutionSpace</a> (firm::SpaceInformation::SpaceInformationPtr executionSI)</td></tr>
<tr class="memdesc:a48e376e8a18712fffcb72e9f5ef05746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the space information in which the policies are executed. This space may or not be same as the variable si_. Use this feature to change where the control action is executed (ex. real robot, ros/gazebo). <br /></td></tr>
<tr class="separator:a48e376e8a18712fffcb72e9f5ef05746"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a79cb3e3d906cdbe42e2575e992cfac2a"><td class="memItemLeft" align="right" valign="top"><a id="a79cb3e3d906cdbe42e2575e992cfac2a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a79cb3e3d906cdbe42e2575e992cfac2a">addStateToObservationGraph</a> (ompl::base::State *state)</td></tr>
<tr class="memdesc:a79cb3e3d906cdbe42e2575e992cfac2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the a state to the observation graph. <br /></td></tr>
<tr class="separator:a79cb3e3d906cdbe42e2575e992cfac2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8876d98bfe366711e7a7091c01e48627"><td class="memItemLeft" align="right" valign="top"><a id="a8876d98bfe366711e7a7091c01e48627"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a8876d98bfe366711e7a7091c01e48627">addEdgeToObservationGraph</a> (const Vertex a, const Vertex b)</td></tr>
<tr class="memdesc:a8876d98bfe366711e7a7091c01e48627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an edge between the two vertices. <br /></td></tr>
<tr class="separator:a8876d98bfe366711e7a7091c01e48627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dee1d7f7d5ca23f657cd749e233bba5"><td class="memItemLeft" align="right" valign="top"><a id="a3dee1d7f7d5ca23f657cd749e233bba5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a3dee1d7f7d5ca23f657cd749e233bba5">evaluateObservationListForVertex</a> (const Vertex v)</td></tr>
<tr class="memdesc:a3dee1d7f7d5ca23f657cd749e233bba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of observations that are observed from a Vertex. <br /></td></tr>
<tr class="separator:a3dee1d7f7d5ca23f657cd749e233bba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29daac363c46c665bec19fdcceb6a3b4"><td class="memItemLeft" align="right" valign="top"><a id="a29daac363c46c665bec19fdcceb6a3b4"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a29daac363c46c665bec19fdcceb6a3b4">getObservationOverlap</a> (const Vertex a, const Vertex b, unsigned int &amp;weight)</td></tr>
<tr class="memdesc:a29daac363c46c665bec19fdcceb6a3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the overlap in observation for two vertices. <br /></td></tr>
<tr class="separator:a29daac363c46c665bec19fdcceb6a3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3f35bba1b00976812dbf75d1dc7c07"><td class="memItemLeft" align="right" valign="top"><a id="a1b3f35bba1b00976812dbf75d1dc7c07"></a>
std::vector&lt; Vertex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a1b3f35bba1b00976812dbf75d1dc7c07">getNeighbors</a> (const ompl::base::State *state)</td></tr>
<tr class="memdesc:a1b3f35bba1b00976812dbf75d1dc7c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nodes within some radius "r" to state. <br /></td></tr>
<tr class="separator:a1b3f35bba1b00976812dbf75d1dc7c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5fbec093337b20754472b343c828fc"><td class="memItemLeft" align="right" valign="top"><a id="a0e5fbec093337b20754472b343c828fc"></a>
Vertex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a0e5fbec093337b20754472b343c828fc">findTarget</a> (const unsigned int beliefStateIndx)</td></tr>
<tr class="memdesc:a0e5fbec093337b20754472b343c828fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the target location for the given state. <br /></td></tr>
<tr class="separator:a0e5fbec093337b20754472b343c828fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7b829b03f525ffb2618095b628be80"><td class="memItemLeft" align="right" valign="top"><a id="a5a7b829b03f525ffb2618095b628be80"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a5a7b829b03f525ffb2618095b628be80">calculateIntersectionWithNeighbor</a> (const Vertex v, std::vector&lt; Vertex &gt; neighbors)</td></tr>
<tr class="memdesc:a5a7b829b03f525ffb2618095b628be80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the total weight of the edges from v to nodes in the given neighbor set. <br /></td></tr>
<tr class="separator:a5a7b829b03f525ffb2618095b628be80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad047dadf01b4c4aea5d75ef34f384301"><td class="memItemLeft" align="right" valign="top"><a id="ad047dadf01b4c4aea5d75ef34f384301"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#ad047dadf01b4c4aea5d75ef34f384301">areSimilarWeights</a> ()</td></tr>
<tr class="memdesc:ad047dadf01b4c4aea5d75ef34f384301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all weights are same, false otherwise. <br /></td></tr>
<tr class="separator:ad047dadf01b4c4aea5d75ef34f384301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0139a2cef346c19869dbb900a9f648a"><td class="memItemLeft" align="right" valign="top"><a id="af0139a2cef346c19869dbb900a9f648a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#af0139a2cef346c19869dbb900a9f648a">removeDuplicateModes</a> ()</td></tr>
<tr class="memdesc:af0139a2cef346c19869dbb900a9f648a"><td class="mdescLeft">&#160;</td><td class="mdescRight">if 2 modes have the same weight and pose, then they are duplicates <br /></td></tr>
<tr class="separator:af0139a2cef346c19869dbb900a9f648a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8ee9978daa9fd57c1fe66be3a87140"><td class="memItemLeft" align="right" valign="top"><a id="a1f8ee9978daa9fd57c1fe66be3a87140"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a1f8ee9978daa9fd57c1fe66be3a87140">drawBeliefs</a> ()</td></tr>
<tr class="memdesc:a1f8ee9978daa9fd57c1fe66be3a87140"><td class="mdescLeft">&#160;</td><td class="mdescRight">draw the current beliefs <br /></td></tr>
<tr class="separator:a1f8ee9978daa9fd57c1fe66be3a87140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae785cd0405bb98d27bfc387c5fc77bc4"><td class="memItemLeft" align="right" valign="top"><a id="ae785cd0405bb98d27bfc387c5fc77bc4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#ae785cd0405bb98d27bfc387c5fc77bc4">normalizeWeights</a> ()</td></tr>
<tr class="memdesc:ae785cd0405bb98d27bfc387c5fc77bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the weights of modes. <br /></td></tr>
<tr class="separator:ae785cd0405bb98d27bfc387c5fc77bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24872c915533c3c39c8afd092599eff2"><td class="memItemLeft" align="right" valign="top"><a id="a24872c915533c3c39c8afd092599eff2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a24872c915533c3c39c8afd092599eff2">assignUniformWeight</a> ()</td></tr>
<tr class="memdesc:a24872c915533c3c39c8afd092599eff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets a uniform weight for all modes <br /></td></tr>
<tr class="separator:a24872c915533c3c39c8afd092599eff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab54a9d284dc22393c47bb904a3980540"><td class="memItemLeft" align="right" valign="top"><a id="ab54a9d284dc22393c47bb904a3980540"></a>
std::vector&lt; ompl::base::State * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#ab54a9d284dc22393c47bb904a3980540">currentBeliefStates_</a></td></tr>
<tr class="memdesc:ab54a9d284dc22393c47bb904a3980540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for the current modes/beliefs. <br /></td></tr>
<tr class="separator:ab54a9d284dc22393c47bb904a3980540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e44c4aab83bddb3f19e709079da8a14"><td class="memItemLeft" align="right" valign="top"><a id="a1e44c4aab83bddb3f19e709079da8a14"></a>
std::vector&lt; ompl::base::State * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a1e44c4aab83bddb3f19e709079da8a14">targetStates_</a></td></tr>
<tr class="memdesc:a1e44c4aab83bddb3f19e709079da8a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">The target location for each corresponding belief. <br /></td></tr>
<tr class="separator:a1e44c4aab83bddb3f19e709079da8a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6505f2dd7bb3dbf7b1a26ca2bf07dc"><td class="memItemLeft" align="right" valign="top"><a id="a4c6505f2dd7bb3dbf7b1a26ca2bf07dc"></a>
firm::SpaceInformation::SpaceInformationPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a4c6505f2dd7bb3dbf7b1a26ca2bf07dc">si_</a></td></tr>
<tr class="memdesc:a4c6505f2dd7bb3dbf7b1a26ca2bf07dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the state space information. <br /></td></tr>
<tr class="separator:a4c6505f2dd7bb3dbf7b1a26ca2bf07dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4ddb656f5f8ec781bd07771f18e83f"><td class="memItemLeft" align="right" valign="top"><a id="a9d4ddb656f5f8ec781bd07771f18e83f"></a>
firm::SpaceInformation::SpaceInformationPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a9d4ddb656f5f8ec781bd07771f18e83f">policyExecutionSI_</a></td></tr>
<tr class="memdesc:a9d4ddb656f5f8ec781bd07771f18e83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the space in which the policy is executed. By default it is set to the same space that is passed to the constructer. If this space is changed, the observations and controls are both in the context of this new space. Use the setPolicyExecutionSpace function to change this parameter. Particularly useful if you wish to drive a real robot and get sensor readings. <br /></td></tr>
<tr class="separator:a9d4ddb656f5f8ec781bd07771f18e83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8303a635a8a127056e48928b721d1269"><td class="memItemLeft" align="right" valign="top"><a id="a8303a635a8a127056e48928b721d1269"></a>
std::vector&lt; ompl::control::Control * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a8303a635a8a127056e48928b721d1269">previousPolicy_</a></td></tr>
<tr class="memdesc:a8303a635a8a127056e48928b721d1269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for the previous open loop policy. <br /></td></tr>
<tr class="separator:a8303a635a8a127056e48928b721d1269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbb021ca2cb7147bbd86b424b5916bb"><td class="memItemLeft" align="right" valign="top"><a id="a9bbb021ca2cb7147bbd86b424b5916bb"></a>
std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a9bbb021ca2cb7147bbd86b424b5916bb">weights_</a></td></tr>
<tr class="memdesc:a9bbb021ca2cb7147bbd86b424b5916bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for the current weights of the beliefs. <br /></td></tr>
<tr class="separator:a9bbb021ca2cb7147bbd86b424b5916bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d09fe5f1740d998ae63bfe60239ce8"><td class="memItemLeft" align="right" valign="top"><a id="a35d09fe5f1740d998ae63bfe60239ce8"></a>
Graph&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a35d09fe5f1740d998ae63bfe60239ce8">g_</a></td></tr>
<tr class="memdesc:a35d09fe5f1740d998ae63bfe60239ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">connectivity graph (observation graph) <br /></td></tr>
<tr class="separator:a35d09fe5f1740d998ae63bfe60239ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7069dd6ab7e1f4f82b1eea703145b552"><td class="memItemLeft" align="right" valign="top"><a id="a7069dd6ab7e1f4f82b1eea703145b552"></a>
boost::property_map&lt; Graph, <a class="el" href="struct_n_b_m3_p_1_1vertex__state__t.html">vertex_state_t</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a7069dd6ab7e1f4f82b1eea703145b552">stateProperty_</a></td></tr>
<tr class="memdesc:a7069dd6ab7e1f4f82b1eea703145b552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the internal ompl::base::state at each Vertex. <br /></td></tr>
<tr class="separator:a7069dd6ab7e1f4f82b1eea703145b552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1710534b402342904c1dc5b0cb311a64"><td class="memItemLeft" align="right" valign="top"><a id="a1710534b402342904c1dc5b0cb311a64"></a>
boost::property_map&lt; Graph, boost::edge_weight_t &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a1710534b402342904c1dc5b0cb311a64">weightProperty_</a></td></tr>
<tr class="memdesc:a1710534b402342904c1dc5b0cb311a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the weights of each Edge. <br /></td></tr>
<tr class="separator:a1710534b402342904c1dc5b0cb311a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbab5abc9163ec04ce900b607e9fee89"><td class="memItemLeft" align="right" valign="top"><a id="acbab5abc9163ec04ce900b607e9fee89"></a>
boost::property_map&lt; Graph, boost::edge_index_t &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#acbab5abc9163ec04ce900b607e9fee89">edgeIDProperty_</a></td></tr>
<tr class="memdesc:acbab5abc9163ec04ce900b607e9fee89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the indices of each Edge. <br /></td></tr>
<tr class="separator:acbab5abc9163ec04ce900b607e9fee89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc2afc2ddf851a7e31e0f3d6e21c6d9"><td class="memItemLeft" align="right" valign="top">std::map&lt; Vertex, std::vector&lt; unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a3dc2afc2ddf851a7e31e0f3d6e21c6d9">stateObservationProperty_</a></td></tr>
<tr class="memdesc:a3dc2afc2ddf851a7e31e0f3d6e21c6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure that maintains the connected components.  <a href="#a3dc2afc2ddf851a7e31e0f3d6e21c6d9">More...</a><br /></td></tr>
<tr class="separator:a3dc2afc2ddf851a7e31e0f3d6e21c6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d28b9df3354265002914a2c39244d9"><td class="memItemLeft" align="right" valign="top"><a id="a12d28b9df3354265002914a2c39244d9"></a>
boost::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a12d28b9df3354265002914a2c39244d9">graphMutex_</a></td></tr>
<tr class="memdesc:a12d28b9df3354265002914a2c39244d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to guard access to the Graph member (g_) <br /></td></tr>
<tr class="separator:a12d28b9df3354265002914a2c39244d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fa80663a9f07dbd9f70436c612c2fe"><td class="memItemLeft" align="right" valign="top"><a id="aa9fa80663a9f07dbd9f70436c612c2fe"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#aa9fa80663a9f07dbd9f70436c612c2fe">maxEdgeID_</a></td></tr>
<tr class="memdesc:aa9fa80663a9f07dbd9f70436c612c2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to track the maximum number of Edges in the Uniqueness graph. <br /></td></tr>
<tr class="separator:aa9fa80663a9f07dbd9f70436c612c2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fd0532feff16fc90da8cf3fcfc394d"><td class="memItemLeft" align="right" valign="top"><a id="a27fd0532feff16fc90da8cf3fcfc394d"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_b_m3_p.html#a27fd0532feff16fc90da8cf3fcfc394d">timeSinceDivergence_</a></td></tr>
<tr class="memdesc:a27fd0532feff16fc90da8cf3fcfc394d"><td class="mdescLeft">&#160;</td><td class="mdescRight">keep a track of how long a belief has been predicting to observe something that is not seen by the robot <br /></td></tr>
<tr class="separator:a27fd0532feff16fc90da8cf3fcfc394d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_n_b_m3_p.html">NBM3P</a> is a planner for Non-Gaussian Belief State. Stated simply, its job is to generate the best next control to disambiguate the belief given the current modes. Key features:</p>
<p>1) We represent the belief with a Gaussian Mixture Model (GMM) rather than particles.</p>
<p>2) Instead of basing actions on the most-likely hypothesis, we create candidate actions based on each mode and evaluate the best one.</p>
<p>3) We use a sampling based planner i.e. RRT* to plan candidate trajectories. (One can also simply use RRTs but due to insignificant overhead in using RRT* over RRT we prefer RRT* as it gives us the benefit of optimality)</p>
<p>4) We introduce a switching behavior in the belief representation during the online-phase from Gaussian to non-Gaussian, and back, as required. Our argument is that most of the times, the belief is well represented by a Gaussian, wherever this is not the case, we switch to a GMM and our algorithm creates plans that converge back to a uni-modal Gaussian.</p>
<p>5) We present simulation results for a 2D navigation problem in which a robot is kidnapped. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a8070db8f34e54556aef56f221c7f5b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8070db8f34e54556aef56f221c7f5b4d">&#9670;&nbsp;</a></span>executeOpenLoopPolicyOnMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ompl::base::Cost NBM3P::executeOpenLoopPolicyOnMode </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; ompl::control::Control *&gt;&#160;</td>
          <td class="paramname"><em>controls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ompl::base::State *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs the open loop policy on a given mode and outputs the cost. </p>
<p><a class="el" href="class_n_b_m3_p.html#a044d5ea04e213cfba2dc959cfa0edb78" title="Returns true if all beliefs are valid i.e. collision free. ">areCurrentBeliefsValid()</a> </p>

</div>
</div>
<a id="ab5073bfd28c8e31f508a52f848b6ac1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5073bfd28c8e31f508a52f848b6ac1b">&#9670;&nbsp;</a></span>generatePolicy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NBM3P::generatePolicy </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; ompl::control::Control *&gt; &amp;&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the current belief states and target states, output the best policy. </p>
<p>This function does the majority work. It will use an RRT to generate open loop control policies based on each mode to its target. Then evaluate each policy on each mode and return the best policy to be followed. We will then apply this policy to the true state i.e. the robot and update all the beliefs. This process would then get repeated. </p>

</div>
</div>
<a id="acad7379ed7dc0d3f4860d4a363aedafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad7379ed7dc0d3f4860d4a363aedafd">&#9670;&nbsp;</a></span>getCurrentBeliefStates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NBM3P::getCurrentBeliefStates </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; ompl::base::State *&gt; &amp;&#160;</td>
          <td class="paramname"><em>states</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Get the current belief states </p>

</div>
</div>
<a id="a50c2f81984f30c6f129d3384420ec1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c2f81984f30c6f129d3384420ec1ff">&#9670;&nbsp;</a></span>sampleNewBeliefStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NBM3P::sampleNewBeliefStates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function samples the beliefs, which form the starting point for the multi-modal scenario. </p>
<p>Logic:</p><ol type="1">
<li>Grid the environment</li>
<li>At each point in grid, put a robot with periodic orientations (10 degree spacing)</li>
</ol>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3dc2afc2ddf851a7e31e0f3d6e21c6d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc2afc2ddf851a7e31e0f3d6e21c6d9">&#9670;&nbsp;</a></span>stateObservationProperty_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;Vertex, std::vector&lt;unsigned int&gt; &gt; NBM3P::stateObservationProperty_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data structure that maintains the connected components. </p>
<p>Stores the list of ids of landmarks that a vertex in the graph can see </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/redwan/POMDP/FIRM/edpl-ompl/include/Planner/<a class="el" href="_n_b_m3_p_8h_source.html">NBM3P.h</a></li>
<li>/home/redwan/POMDP/FIRM/edpl-ompl/src/Planner/NBM3P.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 8 2019 11:17:33 for EDPL-OMPL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
